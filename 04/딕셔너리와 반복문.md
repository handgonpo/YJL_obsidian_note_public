# 🔹 딕셔너리 선언하기 

### 🔹딕셔너리란?
	딕셔너리(dictionary)는 key(키)와 value(값)를 쌍(pair)으로 
	저장하는 자료형입니다.
	예를 들어 "이름": "영희"처럼 어떤 값을 이름표처럼 붙여서 저장하는 
	방식이에요.

◽ 딕셔너리 기본 구조
```python
딕셔너리명 = {     
	키1: 값1,     
	키2: 값2,     
	키3: 값3 
}
```

- 키는 중복될 수 없으며, 값을 이름처럼 구분할 때 사용합니다.
- 리스트는 순서(index)로 꺼내지만, 딕셔너리는 키(key)로 꺼냅니다.

</> 예시코드:
```python
user = {
    "name": "지민",
    "age": 28,
    "hobbies": ["독서", "사진", "요가"],
    "education": {
        "highschool": {
            "name": "서울고등학교",
            "graduated": True
        },
        "university": {
            "name": "한국대학교",
            "major": "심리학",
            "graduated": False
        }
    },
    "friends": [
        {"name": "태형", "age": 27},
        {"name": "석진", "age": 29}
    ]
}
```

◽ 시각적으로 표현한 구조
```python
user
├── name: "지민"
├── age: 28
├── hobbies: ["독서", "사진", "요가"]
├── education
│   ├── highschool
│   │   ├── name: "서울고등학교"
│   │   └── graduated: True
│   └── university
│       ├── name: "한국대학교"
│       ├── major: "심리학"
│       └── graduated: False
└── friends
    ├── {"name": "태형", "age": 27}
    └── {"name": "석진", "age": 29}
```

🔍 구조형태 해설:
	계층 리스트 형태입니다.

---
1️⃣ 딕셔너리 안에 리스트 넣기
```python
person = {
    "name": "영희",
    "hobbies": ["독서", "요리", "등산"]
}
print(person["hobbies"][1])  # 요리
```

🧾 보충설명:
	`"hobbies"`라는 키에 리스트를 값으로 넣었습니다.
	`["독서", "요리", "등산"]` 중 두 번째 값인 `"요리"`에 접근할 수 있어요.

---
2️⃣ 리스트 안에 딕셔너리 넣기
```python
people = [
    {"name": "영희", "age": 20},
    {"name": "철수", "age": 22}
]
print(people[1]["name"])  # 철수
```

🧾 보충설명:
	리스트 안에 딕셔너리 2개가 들어 있어요.
	`people[1]`은 두 번째 사람이고, 그 사람의 `"name"`은 `"철수"`입니다.

---
# 🔹 딕셔너리의 요소에 접근하기
	파이썬 딕셔너리에서는 숫자 인덱스 대신 키(key)를 사용해 값을 
	꺼냅니다.  

📖 문법, 구문(syntax):  딕셔너리 값 꺼내는 기본 문법
```python
딕셔너리["키"]
```
---
</> 예시코드: 키로 값 꺼내기
```python
user = {"name": "영희", "age": 20}
print(user["name"])  # 영희
print(user["age"])   # 20
```

🖨️ 출력 결과:
```python
영희   
20
```

🔍 해설:
- `"name"`과 `"age"`는 키(key)
- 해당 키를 `[]` 안에 넣어서 값을 가져올 수 있어요
---
</>예시코드2 : 딕셔너리에서 값 꺼내기 (key로 접근)
```python
student = {
    "name": "영희",
    "scores": [85, 92, 78],
    "profile": {
        "age": 21,
        "city": "서울"
    }
}

# 각 값 꺼내기
print(student["name"])           # 영희
print(student["scores"][1])      # 두 번째 점수 92
print(student["profile"]["city"])  # 사는 도시 서울
```

🖨️ 출력 결과:
```python
영희
92
서울
```

🔍 해설:
- `student["name"]` → 딕셔너리에서 `"name"` 키에 해당하는 값 `"영희"` 출력
- `student["scores"][1]` → `"scores"` 키는 리스트이므로, 리스트 인덱스 `[1]` 로 `"92"` 출력
- `student["profile"]["city"]` → `"profile"`은 딕셔너리, 그 안에서 `"city"` 키를 꺼내 `"서울"` 출력
---
</>예시코드3 :
```python
person = {     
	"name": "영희",
    "age": 21,
    "address": {
        "city": "서울",
        "district": "강남구"
    },
    "hobbies": ["독서", "요리", "등산"]
} 
# 출력
print(f"이름: {person['name']}")
print(f"도시: {person['address']['city']}")
print(f"첫 번째 취미: {person['hobbies'][0]}")
print(f"나이: {person['age']}")

# 존재하지 않는 키 접근 (예외 방지)
nickname = person.get("nickname", "별명 없음")
my_age = person.get("age")
print(f"별명: {nickname}")
print(f"나이: {my_age}")

```

🖨️ 출력 결과:
```python
이름: 영희
도시: 서울        
첫 번째 취미: 독서
별명: 별명 없음   
나이: 21
```

🔍 해설:

	"address"는 딕셔너리 내부에 또 다른 딕셔너리가 들어 있는 
	중첩 딕셔너리입니다.
	
	"hobbies"는 리스트를 값으로 가진 항목으로, 리스트 내부 값에 
	인덱스로 접근할 수 있습니다.
	
	person[address][city]는 중첩된 딕셔너리에서 "city"라는 키의 값을
	가져오는 방식입니다.
	
	person[hobbies][0]은 "hobbies" 리스트의 첫 번째 요소(0번 인덱스를
	출력합니다.
	
	person.get("nickname", "별명 없음")은 "nickname"이라는 키가 없을
	경우 에러 대신 기본값("별명 없음")을 반환합니다.
---
📝 문제1] 
다음과 같은 사용자 정보 딕셔너리가 있습니다.  
이름과 나이를 이용해 아래와 같은 형식으로 출력하세요.

 `"홍길동님은 성인입니다."`  
 `"김초롱님은 미성년자입니다."`
```python
users = [
    {"name": "홍길동", "age": 22},
    {"name": "김초롱", "age": 17}
]
```

🖨️ 출력 결과:
```python
홍길동님은 성인입니다.  
김초롱님은 미성년자입니다.
```

✅ 정답 코드:
```python
users = [
    {"name": "홍길동", "age": 22},
    {"name": "김초롱", "age": 17}
]

for user in users:
    if user["age"] >= 20:
        print(f"{user['name']}님은 성인입니다.")
    else:
        print(f"{user['name']}님은 미성년자입니다.")
```

🔍 해설:
- 딕셔너리 리스트를 반복문으로 순회
- 조건 분기
- `f-string` 포맷

---
📝 문제2] 
다음과 같은 딕셔너리 2개가 있습니다.  
두 딕셔너리를 합쳐서 `user_profile`이라는 하나의 딕셔너리로 만들고 출력하세요.
```python
base_info = {"name": "민수", "age": 30}
extra_info = {"email": "minsu@example.com", "phone": "010-0000-0000"}
```

🖨️ 출력 결과:
```python
{'name': '민수', 'age': 30, 'email': 'minsu@example.com', 'phone': '010-0000-0000'}
```

✅ 정답 코드:
```python
base_info = {"name": "민수", "age": 30}
extra_info = {"email": "minsu@example.com", "phone": "010-0000-0000"}

user_profile = {**base_info, **extra_info}
print(user_profile)
```

🔍 해설:
- 전개 연산자 `**`를 이용한 딕셔너리 병합
- 실무에서는 API 응답 통합, 사용자 기본 + 추가 정보 결합 등에 사용
---
📝 문제3] 
다음 딕셔너리에서 `score`가 존재하는 경우 `"점수 있음"`,  
존재하지 않으면 `"점수 없음"`을 출력하는 코드를 작성하세요.  
`[]` 접근을 쓰면 오류가 납니다. 안전하게 처리하세요.
```python
student = {"name": "지연", "age": 19}
```

🖨️ 출력 결과:
```python
점수 없음
```

✅ 정답 코드:
```python
student = {"name": "지연", "age": 19}

if "score" in student:
    print("점수 있음")
else:
    print("점수 없음")
```

🔍 해설:
- 딕셔너리에 키가 있는지 확인할 때는 `"키" in 딕셔너리` 사용
---
🧾 보충설명:  
	리스트는 인덱스로 꺼내고,  
	딕셔너리는 키(key)로 꺼낸다는 점만 확실히 구분하면 됩니다!

---
##### ◽ 딕셔너리의 문자열 키와 관련된 실수
```
딕셔너리에서 문자열 키(key)를 사용할 때 자주 하는 실수가 있어요.  
바로 키 이름을 정확하게 쓰지 않아서 생기는 오류입니다.
딕셔너리에서 값을 꺼낼 때 키는 철자 하나라도 틀리면 오류가 납니다.
"Name"과 "name"은 완전히 다른 키입니다.
```
---
❌ </> 예시코드: 대소문자를 다르게 쓰면 오류 발생
```python
user = {     
	"name": "영희" 
} 

print(user["Name"])  # ❌
```

🖨️ 오류 메시지:
```python
KeyError: 'Name'
```

🔍 해설:
- `"name"`과 `"Name"`은 완전히 다른 문자열
- 파이썬의 딕셔너리는 대소문자를 구분하기 때문에  
    철자가 조금이라도 다르면 키를 찾지 못함

---
❌ </> 예시코드: 오타가 섞이면 오류 발생
```python
student = {     
	"score": 95 
} 

print(student["socre"])  # ❌ 오타!
```

🖨️ 오류 메시지:
```python
KeyError: 'socre'
```

🔍 해설:

- `"socre"`는 `"score"`의 오타
- 철자 하나 차이로도 딕셔너리는 다른 키로 인식
- 따라서 정확한 철자로 접근해야 함
---
</> 예시코드: 외부 데이터와 키 이름 불일치

상황 설명:  
당신은 사용자 정보를 담은 딕셔너리를 가지고 있고, 외부 API 또는 입력폼에서 받은 키 값을 기준으로 값을 꺼내야 합니다.  
그런데 외부 키는 `"UserName"`처럼 대문자가 섞여 있고,  
내부 딕셔너리에는 `"username"`처럼 소문자로 저장되어 있습니다.
```python
# 외부에서 들어온 키 (대소문자 섞여 있음)
requested_key = "UserName"

# 내부 시스템에서 사용하는 딕셔너리
user_info = {
    "username": "kim_92",
    "email": "kim@example.com"
}

# 값 출력
print("사용자 이름:", user_info[requested_key])
```

🖨️ 오류 메시지:
```python
KeyError: 'UserName'
```

---
✅ 해결법 1: `.get()` + `lower()` 조합
```python
requested_key = "UserName"
user_info = {
    "username": "kim_92",
    "email": "kim@example.com"
}

# 외부 키를 소문자로 정규화
key = requested_key.lower()

# 안전하게 값 꺼내기
print("사용자 이름:", user_info.get(key, "정보 없음"))
```

🖨️ 출력 결과:

```python
사용자 이름: kim_92
```
---
✅ 해결법 2: 일반 for문
```python
raw_data = {
    "UserName": "lee_01",
    "Email": "lee@example.com"
}

user_info = {}  # 빈 딕셔너리 생성

for k, v in raw_data.items(): # UserName, lee_01
    lower_key = k.lower()  # 키를 소문자로 변환 v = username email
    user_info[lower_key] = v  # 새 딕셔너리에 저장
    # user_info[username] = v # lee_01
    # user_info[email] = v # lee@example.com
```

✅ 해결법 3: 키 정규화 (모든 키 소문자로 저장)
```python
# 외부에서 받아온 데이터 (키가 대소문자 섞임)
raw_data = {
    "UserName": "lee_01",
    "Email": "lee@example.com"
}

# 모든 키를 소문자로 변환하여 저장(Dictionary Comprehension)
user_info = {k.lower(): v for k, v in raw_data.items()}

# 이제 내부적으로 모두 소문자 키만 사용
print(user_info["username"])  # lee_01
print(user_info.get("email", "정보 없음")) # lee@example.com
```

`raw_data.items()`이란?

- 딕셔너리의 `items()` 메서드는 (키, 값) 쌍을 튜플 형태로 하나씩 꺼냅니다.

```python
for k, v in raw_data.items(): # UserName, lee_01
    print(k, v)
```

🖨️ 출력 결과:
```python
UserName lee_01  
Email lee@example.com
```

여기서:

- `k`는 각각의 키 → `"UserName"`, `"Email"`
- `v`는 각각의 값 → `"lee_01"`, `"lee@example.com"`

딕셔너리 컴프리헨션 작동 과정
```python
user_info = {k.lower(): v for k, v in raw_data.items()}
```

이 문장은 다음과 같이 작동합니다:

|반복|k|v|k.lower()|결과에 추가될 항목|
|---|---|---|---|---|
|1회|"UserName"|"lee_01"|"username"|`"username": "lee_01"`|
|2회|"Email"|"[lee@example.com](mailto:lee@example.com)"|"email"|`"email": "lee@example.com"`|

결과적으로 `user_info`는 다음과 같이 만들어집니다:
```python
{'username': 'lee_01', 'email': 'lee@example.com'}
```

출력 부분 설명:
```python
print(user_info["username"])  # 'lee_01'
print(user_info.get("email", "정보 없음"))  # 'lee@example.com'
```

- 첫 줄: `"username"` 키는 존재하므로 `"lee_01"` 출력
- 두 번째 줄: `"email"`도 존재하므로 `get()`의 기본값은 무시되고 실제 값 출력

🖨️ 출력:
```python
lee_01  
lee@example.com
```
---
# 🔹 딕셔너리에 값 추가하기/제거하기

```
딕셔너리는 값을 저장할 뿐만 아니라, 나중에 새로운 키-값 쌍을 
추가하거나 기존 값을 삭제할 수 있어요.  
파이썬에서는 간단한 대입= 과 del 키워드를 이용해 딕셔너리를 수정
할 수 있습니다.
딕셔너리는 실시간으로 값을 추가하거나 지울 수 있는 유연한 구조입니다.
```

---
◽ 값 추가 방법
```python
딕셔너리["새로운_키"] = 값
```

</> 예시코드: 값 추가하기
```python
person = {"name": "영희"} 
person["age"] = 21 
print(person)
```

🖨️ 출력 결과:
```python
{'name': '영희', 'age': 21}
```

🔍 해설:
- `"age"`라는 새 키에 `21`이라는 값을 대입
- 딕셔너리에 항목이 추가됨
---
### 🔷 중첩 딕셔너리에 값을 추가하는 방법들

◽ 중첩 딕셔너리 전체를 한 번에 추가
```python
user = {}

# 중첩 딕셔너리 전체를 추가
user["address"] = {
    "city": "서울",
    "zip": "12345"
}
print(user)
```

- 이 방식은 `"address"`라는 키에 딕셔너리 전체를 한 번에 통째로 추가합니다.

 🖨️ 출력 결과:
```python
{'address': {'city': '서울', 'zip': '12345'}}
```
---
◽ 중첩 딕셔너리의 하위 키만 나중에 추가
```python
user = {"address": {}}  # 먼저 빈 딕셔너리 생성

# 중첩된 딕셔너리에 값 추가
user["address"]["city"] = "서울"
user["address"]["zip"] = "12345"
print(user)
```

- 이 방식은 중첩된 딕셔너리 안에 하나씩 값을 넣는 점(dot) 방식의 단계적 접근입니다.

🖨️ 출력 결과:
```python
{'address': {'city': '서울', 'zip': '12345'}}
```
---
◽ 중첩 구조를 여러 계층으로 추가
```python
user = {}
user["info"] = {}
user["info"]["address"] = {}
user["info"]["address"]["city"] = "서울"
user["info"]["address"]["zip"] = "12345"
print(user)
```

🖨️ 출력 결과:
```python
{'info': {'address': {'city': '서울', 'zip': '12345'}}}
```
---
◽  조건부 키 존재 확인 후 중첩 추가
```python
user = {}

if "address" not in user: # 만약 user 딕셔너리에 address키가 없다면
    user["address"] = {}

user["address"]["city"] = "서울"
print(user)
```

🖨️ 출력 결과:
```python
{'address': {'city': '서울'}}
```
---
◽  `setdefault()` 활용한 짧은 방식
```python
user = {}
user.setdefault("address", {})["city"] = "서울"
user["address"]["zip"] = "12345"
print(user)
```

🖨️ 출력 결과:
```python
{'address': {'city': '서울', 'zip': '12345'}}
```
---
### 🔷 딕셔너리에서 값을 제거하는 방법들

◽ 값 제거 방법
```python
del 딕셔너리["키"]
```

</> 예시코드: 
```python
person = {'name': '영희', 'age': 21}

del person["name"]
print(person)
```

🖨️ 출력 결과:
```python
{'age': 21}
```

🔍 해설:
- 특정 `"name"` 키를 완전히 제거함
- 키가 존재하지 않으면 오류(KeyError) 발생
---
◽ `.pop("키")` — 키를 제거하고 값 반환

</> 예시코드: 
```python
person = {'name': '영희', 'age': 21}

removed = person.pop("name")
print("삭제된 값:", removed)
print(person)
```

🖨️ 출력 결과:
```python
삭제된 값: 영희
{'age': 21}
```

🔍 해설:
- `"name"` 키를 제거하면서 값을 변수에 반환
- 존재하지 않는 키를 제거하면 오류 발생 (예외처리 필요)
---
◽ `.pop("키", 기본값)` — 존재하지 않아도 오류 없이 삭제

</> 예시코드: 
```python
person = {'age': 21}

removed = person.pop("name", "없음")
print("삭제된 값:", removed)
print(person)
```

🖨️ 출력 결과:
```python
삭제된 값: 없음
{'age': 21}
```

🔍 해설:
- `"name"` 키가 없어도 기본값을 반환하고 오류 없이 진행
- 안정적인 삭제 방식
---
◽ `.popitem()` — 마지막 키-값 쌍 삭제

</> 예시코드: 
```python
person = {'name': '영희', 'age': 21}

removed = person.popitem()
print("삭제된 항목:", removed)
print(person)
```

🖨️ 출력 결과:
```python
삭제된 항목: ('age', 21)
{'name': '영희'}
```

🔍 해설:
- 딕셔너리에서 마지막에 추가된 항목을 삭제
- 반환값은 `(키, 값)` 형태의 튜플
- 비어 있으면 오류 발생
---
◽ `.clear()` — 전체 삭제

</> 예시코드: 
```python
person = {'name': '영희', 'age': 21}

person.clear()
print(person)
```

🖨️ 출력 결과:
```python
{}
```

🔍 해설:
- 딕셔너리의 모든 항목을 한 번에 삭제
- 딕셔너리는 존재하지만 내용만 빈 상태가 됨
---
📝 문제1] 사용자의 주소 정보를 조건에 따라 딕셔너리에 추가하세요.
```python
user = {"name": "민수"}
city = input("도시를 입력하세요: ")
```

✨ 조건:
- 만약 사용자가 아무 입력도 하지 않으면 `"city"` 키는 추가하지 마세요.
- 사용자가 입력했다면 `"address"`라는 키 아래 `"city"` 키로 값을 저장하세요.
- 최종 결과를 출력하세요.
```python
user = {"name": "민수"}
city = input("도시를 입력하세요: ").strip()
```

🖨️ 출력 결과: 입력 서울
```python
{'name': '민수', 'address': {'city': '서울'}}
```

(입력 없이 엔터)
```python
{'name': '민수'}
```

✅ 정답 코드:
```python
user = {"name": "민수"}
city = input("도시를 입력하세요: ").strip()

if city:
    user["address"] = {"city": city}

print(user)
```

🔍 해설:
- 입력이 비어 있지 않으면 `address` 키를 만들어 내부에 `city`를 넣습니다.
- 빈 입력은 조건문에서 거르므로 `address`는 추가되지 않습니다.
---
📝 문제2] 딕셔너리에서 `"score"` 키를 삭제해보세요.
```python
student = {"name": "수진", "score": 90}
```

✅ 정답 코드:
```python
del student["score"] 
print(student)
```

🖨️ 출력 결과:
```python
{'name': '수진'}
```
---
📝 문제3] 아래의 딕셔너리에서 `"email"` 키와 해당 값을 제거해보세요.
```python
user = {
    "name": "민수",
    "age": 30,
    "email": "minsu@example.com"
}
```
제거한 뒤, 전체 딕셔너리를 출력해보세요.

🖨️ 출력 결과
```python
{'name': '민수', 'age': 30}
```

✅ 정답 코드:
```python
user = {
    "name": "민수",
    "age": 30,
    "email": "minsu@example.com"
}

del user["email"]
print(user)
```

🔍 해설
- `del 딕셔너리["키"]`를 사용하면 해당 키-값 쌍을 제거할 수 있습니다.
- 존재하지 않는 키를 제거하려고 하면 `KeyError`가 발생하므로 주의하세요.
---
📝 문제4] 중첩 딕셔너리 내부 값 제거하기
다음 중첩 딕셔너리에서 `"zip"` 키를 제거하고 결과를 출력하세요.
```python
user = {
    "name": "영희",
    "address": {
        "city": "서울",
        "district": "강남구",
        "zip": "12345"
    }
}
```

🖨️ 출력 결과:
```python
{
    'name': '영희',
    'address': {
        'city': '서울',
        'district': '강남구'
    }
}
```

✅ 정답 코드:
```python
user = {
    "name": "영희",
    "address": {
        "city": "서울",
        "district": "강남구",
        "zip": "12345"
    }
}

del user["address"]["zip"]
print(user)
```

🔍 해설
- 중첩된 딕셔너리 안의 키를 삭제할 때는 `딕셔너리["키1"]["키2"]` 형식으로 접근해야 합니다.
- `zip`은 `address`라는 딕셔너리 안에 있는 키이므로 `user["address"]["zip"]`으로 접근합니다
---
### 🔹 KeyError 예외란?
	딕셔너리에서 존재하지 않는 키(key)를 꺼내거나 삭제하려고 하면 
	발생하는 오류입니다.

---
</> 예시코드: 없는 키로 값을 꺼내려 할 때
```python
person = {"name": "유정"} 
print(person["age"])  # ❌
```

🖨️ 출력 결과:
```python
KeyError: 'age'
```

🔍 해설:
- `"age"`라는 키는 존재하지 않음
- `[]` 접근 방식은 무조건 있어야 하므로, 없으면 오류 발생

---
</> 예시코드: 존재하지 않는 키 삭제할 때
```python
my_dict = {"name": "지민"}
del my_dict["age"]  # ❌ age 키는 없음
```

🖨️ 출력 결과:
```python
KeyError: 'age'
```

🔍 해설:
- `age` 키가 없기 때문에 `del` 실행 시 오류 발생

---
### 🔹 딕셔너리 내부에 키가 있는지 확인하기
	파이썬 딕셔너리는 값을 찾을 때도 항상 키(key)를 기준으로 찾습니다.  
	그래서 그 키가 딕셔너리에 있는지 먼저 확인하는 습관이 중요합니다.

💡 딕셔너리에 "이 키가 있나?"를 확인하려면  `in` 또는 `get()`을 사용하세요!

| 방법                     | 설명                             | 장점               |
| ---------------------- | ------------------------------ | ---------------- |
| `"키" in 딕셔너리`          | 키가 있으면 `True`, <br>없으면 `False` | `KeyError` 방지 가능 |
| `딕셔너리.get("키")`        | 키가 없으면 `None` 반환               | 에러 없이 안전하게 처리 가능 |
| `딕셔너리.get("키", "기본값")` | 키가 없으면 기본값 반환                  | 사용자 친화적 메시지 가능   |

---
##### ◽ `in` 키워드
	in 키워드는 해당 키가 딕셔너리에 존재하는지 여부를 True / False로 
	알려줍니다.

📖 문법, 구문(syntax): 
```python
"키" in 딕셔너리       # 키가 존재하면 True
"키" not in 딕셔너리   # 키가 존재하지 않으면 True
```

</> 예시코드:
```python
user = {"name": "영희", "age": 20}

print("name" in user)      # True (존재함)
print("gender" in user)    # False (존재하지 않음)

print("age" not in user)   # False (존재하니까)
print("city" not in user)  # True (없으니까)
```
---
🔸 `in` 키워드
	 `"이 서랍(label)이 있나요?"`를 물어보는 것처럼,  값을 꺼내기 전에 `"age"`라는 키가 있는지 먼저 확인합니다.
```python
user = {"name": "영희", "age": 20}

if "age" in user:     
    print(f"나이는 {user['age']}살입니다!")
else:
    print("나이 정보가 없습니다.")
```

🖨️ 출력:
```python
나이는 20살입니다!
```

- 존재하는 `"age"` 키에 안전하게 접근

---
◽  존재하지 않는 키를 미리 검사해 KeyError 방지
	`"gender"`라는 키가 없기 때문에,  미리 확인하지 않으면 `KeyError`가 발생할 수 있어요.

</> 예시코드:
```python
my_dict = {"name": "지민"}

if "gender" in my_dict:
    print(f"성별: {my_dict['gender']}")
else:
    print("gender 키가 존재하지 않아요.")
```

🖨️ 출력:
```python
gender 키가 존재하지 않아요.
```

- 키가 없을 경우를 고려해 안전하게 처리
---
##### ◽ `get()` 함수
	키가 있으면 해당 값을, 없으면 None 또는 기본값을 반환합니다.  
	 KeyError를 방지하는 데 유용합니다.
	 
📖 문법, 구문(syntax): 
```python
딕셔너리.get("키")            # 키가 없으면 None 반환
딕셔너리.get("키", "기본값")   # 키가 없으면 기본값 반환
```

</> 예시코드1:  키가 없을 때 안전하게 처리
```python
user = {"name": "영희"}

print(user.get("age"))               # 키가 없으면 → None
print(user.get("age", "정보 없음"))  # 키가 없으면 → "정보 없음"
```

🖨️ 출력 결과:
```python
None
정보 없음
```

</> 예시코드2:  키가 있을 때는 값 반환
```python
user = {"name": "영희", "age": 22}

print(user.get("name"))              # "영희"
print(user.get("age", "없음"))       # 22 → 기본값 무시됨
```

🖨️ 출력 결과:
```python
영희
22
```

🔍 해설:
- 존재하는 키 조회: 해당 값 반환
- 존재하지 않는 키 조회: `None` 또는 기본값

💡 요약정리:
	존재하는 키 사용: 정상 작동
	존재하지 않는 키 사용: `KeyError` 발생
	`.get()` 함수 사용: 오류 없이 기본값 반환
	`"키" in 딕셔너리` 사용: 키 존재 여부 먼저 확인 가능

---
📝 문제1] 아래 딕셔너리에 `"job"` 키가 없을 때, `"직업 정보 없음"`을 출력해보세요.
```python
person = {"name": "윤아", "age": 28}
```

✅ 정답 코드:
```python
print(person.get("job", "직업 정보 없음"))
```

🖨️ 출력 결과:
```python
직업 정보 없음
```

---
📝 문제2] 아래 딕셔너리에서 `"email"` 키가 **존재할 때만** 이메일을 출력하고, 없으면 `"이메일 정보 없음"`을 출력하세요.
```python
user = {
    "name": "지민",
    "age": 25
}
```

✅ 정답 코드:
```python
if "email" in user:
    print("이메일:", user["email"])
else:
    print("이메일 정보 없음")
```

🖨️ 출력 결과:
```python
이메일 정보 없음
```

🔍 해설:
- `"email" in user`로 먼저 키 존재 여부를 검사하여 `KeyError`를 방지합니다.
---
📝 문제3] 다음 조건을 만족하도록 코드를 완성하세요.

딕셔너리 `book = {"title": "AI 101"}`
- `"author"` 키가 없을 경우 추가하고 `"미상"` 값을 넣기
- 결과 딕셔너리를 출력하세요.

✅ 정답 코드:
```python
book = {"title": "AI 101"}

if "author" not in book:
    book["author"] = "미상"

print(book)
```

🖨️ 출력 결과:
```python
{'title': 'AI 101', 'author': '미상'}
```

🔍 해설:
- 키가 없을 때만 값을 추가하는 조건문 활용 예시입니다.

---
📝 문제4] 사용자 입력을 받아 `"email"` 키가 존재하지 않으면 자동으로 추가하고 `"이메일 미입력"`으로 설정되도록 하세요.

❗ 단, `setdefault()`를 활용할 것

✅ 정답 코드:
```python
user = {"name": "혜진"}

# 자동 추가: 없으면 생성
user.setdefault("email", "이메일 미입력")

print(user)
```

🖨️ 출력 결과:
```python
{'name': '혜진', 'email': '이메일 미입력'}
```

🔍 해설:
- `.setdefault("키", 기본값)`은 키가 없을 경우에만 추가합니다.
- 이미 존재하는 키는 덮어쓰지 않습니다.
