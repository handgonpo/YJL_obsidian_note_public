# 🔹 리스트 선언하고 요소에 접근하기
	리스트(list)는 여러 개의 값을 하나로 묶어서 저장할 수 있는 
	자료형입니다.  
	쉽게 말하면, 변수를 여러 개 한 번에 저장할 수 있는 상자예요.
	리스트는 [] 스퀘어 브라켓 안에 값들을, 로 구분해서 넣습니다.

📖 문법, 구문(syntax): 
``` python
리스트이름 = [값1, 값2, 값3, ...]
```

</> 예시코드: 리스트 만들기
```python
mixed_list = ["사과", 10, "바나나", 20, "포도", 30]
print(mixed_list)
```

🖨️ 출력 결과:
```python
['사과', 10, '바나나', 20, '포도', 30]
```

◽ 리스트의 요소를 변경하는 기본 문법과 예시

📖 문법, 구문(syntax): 
```python
리스트[인덱스] = 새로운값
```
- 리스트는 mutable(변경 가능) 자료형이기 때문에, 인덱스를 통해 값을 직접 바꿀 수 있습니다.

</> 예시코드: 숫자 리스트의 요소 변경
```python
numbers = [10, 20, 30]
numbers[1] = 99  # 인덱스 1에 해당하는 20을 99로 변경
print(numbers)
```

🖨️ 출력 결과:
```python
[10, 99, 30]
```

</> 예시코드: 문자열 리스트의 요소 변경
```python
fruits = ["apple", "banana", "cherry"]
fruits[0] = "grape"  # 첫 번째 요소 변경
print(fruits)
```

🖨️ 출력 결과:
```python
['grape', 'banana', 'cherry']
```
---
◽ 리스트 안에 튜플이 있는 경우 (튜플 전체 교체)
	튜플(tuple)은 "수정이 불가능한(immutable) 자료형"입니다.

</> 예시코드: 리스트에 튜플이 담긴 구조
```python
data = [("Tom", 25), ("Lucy", 30)]
```
- `data`는 리스트입니다 → 수정 가능 (mutable)
- `("Tom", 25)`는 튜플입니다 → 수정 불가능 (immutable)

❌ 튜플 자체를 수정하려 하면 에러가 납니다
```python
data = [("Tom", 25), ("Lucy", 30)]
data[0][1] = 26
```

⚠️ 오류:
```python
TypeError: 'tuple' object does not support item assignment
```

하지만 리스트의 요소(튜플 전체)를 통째로 바꾸는 건 가능
```python
data = [("Tom", 25), ("Lucy", 30)]

data[0] = ("Tom", 26)  # 첫 번째 튜플 전체를 새 튜플로 교체
print(data)
```

🖨️ 출력 결과:
```python
[('Tom', 26), ('Lucy', 30)]
```
---
</> 예시코드: 리스트에서 요소에 접근하기 (인덱스 사용)
```python
print(fruits[0])  # 첫 번째 요소 
print(fruits[1])  # 두 번째 요소 
print(fruits[2])  # 세 번째 요소
```

🖨️ 출력 결과:
```python
apple banana cherry
```

🔍 해설:
- 리스트는 0부터 번호(index)가 시작돼요!
- `fruits[0]` → 리스트의 첫 번째 요소
- `fruits[2]` → 리스트의 세 번째 요소
- 순서대로 꺼내 쓸 수 있어서 정렬된 데이터 다룰 때 매우 유용
---
#####  ◽ 리스트에서의 IndexError
	IndexError는 리스트에서 없는 위치(index)를 꺼내려고 할 때 발생하는 
	에러(오류)입니다.
	리스트는 0부터 시작하는 순서(index)를 가지고 있고, 존재하지 않는 
	인덱스를 접근하면 오류가 납니다.
	예를 들어, 3개짜리 리스트에서 4번째 요소를 꺼내면 IndexError 발생!

---
</> 예시코드:  IndexError 발생 예
``` python
fruits = ["apple", "banana"]
print(fruits[3])  # ❌ IndexError 발생
```

🖨️ 출력 결과:
```python
IndexError: list index out of range
```

🔍 해설:
- `nums`는 총 3개 요소 → 인덱스는 `0`, `1`, `2`까지만 있어요.
- `nums[3]`은 존재하지 않는 네 번째 요소를 꺼내려고 해서 오류 발생
- 에러 메시지: `"리스트 인덱스가 범위를 벗어났습니다"`
---
# 🔹 튜플
	튜플은 수정이 안 되는(immutable) 자료형이지만, 그래서 오히려 특정 
	상황에서 더 유용하게 쓰입니다. 한 번 생성하면 내부 값을 변경할 수 
	없는(immutable) 구조입니다. 

```python
example = ("apple", 3, True, "한글")
```

◽ 튜플의 특징:
✅ 변경 불가능하여 안전함: 실수로 값을 수정할 위험이 없음
✅ 딕셔너리 키로 사용 가능: 리스트는 안 되지만, 튜플은 가능
```python
# 리스트를 딕셔너리의 키로 사용하면 오류 발생
my_dict = {
    [1, 2, 3]: "리스트를 키로"  # ❌ 오류
}

# 딕셔너리의 키로 사용 가능
my_dict = {
    (1, 2, 3): "튜플을 키로",
    ("Tom", 25): "사용자 정보 키"
}

print(my_dict[(1, 2, 3)])       # 출력: 튜플을 키로
print(my_dict[("Tom", 25)])     # 출력: 사용자 정보 키
```

🖨️ 출력 결과:
```python
튜플을 키로
사용자 정보 키
```

✅ 속도와 메모리 효율성 우수:	리스트보다 처리 속도가 빠르고 가볍다
✅ 데이터 그룹화 용이:	관련 데이터를 묶어서 하나처럼 다룰 수 있음 
    (예: 좌표, 사용자 정보 등)
```python
# 좌표 기반 정보 저장
locations = {
    (37.5665, 126.9780): "서울 시청",
    (35.1796, 129.0756): "부산 시청"
}

print(locations[(37.5665, 126.9780)])  # 출력: 서울 시청
```
---
# 🔹 리스트 연산자: 연결(+), 반복( ), len( )
	리스트는 숫자처럼 연산자(+, * )를 사용할 수 있는 자료형이에요.  
	또한 len() 함수를 사용하면 리스트에 몇 개의 값이 들어있는지도 
	알 수 있어요. 이 세 가지는 리스트를 다룰 때 가장 기본적인 
	도구입니다.

###### ◽ 주요 연산
| 연산      | 의미            | 예시                                 |
| ------- | ------------- | ---------------------------------- |
| `+`     | 리스트 연결        | `[1, 2] + [3, 4]` → `[1, 2, 3, 4]` |
| `*`     | 리스트 반복        | `[0] * 5` → `[0, 0, 0, 0, 0]`      |
| `len()` | 리스트 길이(요소 개수) | `len([10, 20, 30])` → `3`          |

</> 예시코드: 리스트 연결 (+)
``` python
a = [1, 2]
b = [3, 4]
result = a + b
print(result)
```

🖨️ 출력 결과:
```python
[1, 2, 3, 4]
```

🔍 해설:
- 리스트끼리 `+`를 하면 두 리스트가 합쳐짐
- 단, 숫자처럼 덧셈이 아니라 리스트 연결의 의미임

</> 예시코드: 중첩 리스트 연결 + 연산 순서 주의
```python
a = [1, [2, 3]]
b = [[4, 5], 6]

result = a + b
print(result)
```

🖨️ 출력 결과:
```python
[1, [2, 3], [4, 5], 6]
```

🔍 해설:
- 리스트 `a`와 `b`는 둘 다 중첩 리스트(리스트 안에 리스트)를 포함하고 있음
- `+` 연산자는 리스트의 구조 자체는 변형하지 않고 단순히 이어 붙임
- `[2, 3]`과 `[4, 5]`는 각각 하나의 요소(리스트)로 취급됨
- 따라서 중첩된 구조도 그대로 유지됨
---
</> 예시코드: 리스트 반복 ( )
```python
items = ["apple"] * 3 
print(items)
```

🖨️ 출력 결과:
```python
['apple', 'apple', 'apple']
```

🔍 해설:
- `"apple"`이 3번 반복된 리스트가 만들어짐
- `*`는 리스트를 여러 번 복제할 때 사용돼요

예측 
```python
items = [[0]] * 3
[[0],[0],[0]]

items[0][0] = 100
100 0 0

print(items)
```

🔍 해설:
- `[[0]] * 3`은 `[ [0], [0], [0] ]`처럼 보이지만, 같은 리스트 객체를 3번 복사한 것이에요.
- 그래서 `items[0][0] = 100`으로 바꾸면, 모든 하위 리스트가 함께 바뀌어요.   
- 이것을 얕은 복사(shallow copy)라고 합니다.

◽ 내부처리동작
`items = [[0]] * 3` 
- `[[0]]`는 먼저 `[0]`이라는 리스트 하나를 만듭니다.
- `* 3`은 그 하나의 리스트 객체를 3번 복사하는 게 아니라 "3번 참조"하는 것입니다.
- 즉, 구조는 이렇게 됩니다:
```python
items = [same_list, same_list, same_list]
```
- 각각의 `same_list`는 모두 같은 주소를 가진 `[0]`을 가리켜요.
- 그래서 다음 코드:
```python
items[0][0] = 100
```
이렇게 하면 어떤 일이 일어날까요?
- `items[0]`는 `[0]`이고, 그 안의 `[0][0]`은 `0`입니다.
- 여기에 `100`을 할당하면, 그 주소에 있는 값이 100으로 바뀜
- 그런데 `items[1]`, `items[2]`도 같은 리스트를 가리키고 있으므로 → 같이 바뀜!

```python
items = [[0]] * 3

print(id(items[0]))
print(id(items[1]))
print(id(items[2]))
```

🖨️ 출력 결과:
```
140711368540416  
140711368540416  
140711368540416  
```

🧐 처음 보기엔 이렇게 생각할 수 있어요:
```python
items = [[0]] * 3
```
이 코드를 보면:
	“리스트 `[0]`이 세 번 반복되니까 결과가 `[ [0], [0], [0] ]`처럼 서로 다른 리스트3개가 생기겠지?”  라고 생각하기 쉽습니다.

하지만 실제로는 그렇지 않아요!
	이 코드는 리스트 `[0]`을 하나만 만든 다음에,  
	그 하나의 리스트를 3번 복사하는 게 아니라, 3번 가리키는(참조하는) 방식입니다.
즉, 리스트 하나를 만들어 놓고  3번 똑같이 가리키는 리스트가 되는 거예요.

그래서 다음과 같이 코드를 작성하면:
```python
items[0][0] = 100
```
- 첫 번째 리스트의 값을 `100`으로 바꾼 건데,
- 실제로는 나머지 두 리스트도 같은 것을 가리키고 있기 때문에  
    → 전부 `100`으로 바뀌게 됩니다.

즉 위의 코드는 에러는 아니지만 개발자가 의도하지 않은 결과가 나올 수 있어서, '논리적인 오류' 또는 "함정(bug)"이라고 볼 수 있습니다.
```python
[[100], [0], [0]]  ← (기대했던 결과)
```
위와 같이 나오길 기대했을겁니다.

```python
# 의도한 바가 아니라면 이코드를 아래와 같이 수정하세요
items = [[0]] * 3

# 이렇게 수정합니다.
items = [[0], [0], [0]]
```

해결방법:
```python
items = []
items.append([0])
items.append([0])
items.append([0])

items[0][0] = 100
print(items)
```
---
📝 문제 1] 얕은 복사(shallow copy)
리스트 복사 후 수정해보기 다음 코드를 실행하면 어떤 결과가 출력될까요?
```python
a = [1, 2, 3]
b = a
b[0] = 99
print("a:", a)
print("b:", b)
```

🖨️ 출력 결과:
```python
a: [99, 2, 3]  
b: [99, 2, 3]
```

🔍 해설:
- `b = a`는 리스트를 복사한 게 아니라 같은 객체를 참조한 것
- 따라서 `b[0] = 99`로 값을 바꾸면, `a`도 함께 바뀐다
- 이것이 얕은 복사(shallow copy)의 대표적인 예

◽ a 데이터가 안바뀌게 하려면:
```python
a = [1, 2, 3]
b = a        # ❌ 얕은 복사 (같은 객체를 가리킴)
b[0] = 99
print("a:", a)  # ❌ a도 같이 바뀜 → a: [99, 2, 3]
print("b:", b)
```

</> 깊은 복사(deep copy) 슬라이싱 사용 (`[:]`)
```python
a = [1, 2, 3]
b = a[:]       # 새로운 리스트 복사
b[0] = 99
print("a:", a)  # a: [1, 2, 3]
print("b:", b)  # b: [99, 2, 3]
```

</> 깊은 복사(deep copy) list() 함수 사용
```python
a = [1, 2, 3]
b = list(a)     # 새 리스트 생성
b[0] = 99
print("a:", a)  # a: [1, 2, 3]
print("b:", b)  # b: [99, 2, 3]
```
---
📝 문제 2] 다음 코드를 실행했을 때 출력 결과는?
```python
a = [[1, 2], [3, 4]]
b = a * 2
b[0][0] = 100
print(a)
print(b)
```

🌟 힌트: `* 2`는 얕은 복사입니다. 내부 리스트는 그대로 공유됩니다.

✅ 정답 코드:
```python
[[100, 2], [3, 4]]
[[100, 2], [3, 4], [100, 2], [3, 4]]
```

🔍 해설:
- `a * 2`는 `a[0]`, `a[1]`를 복사하는 것이 아니라 그 리스트를 참조하는 새 리스트를 만듭니다.
- 따라서 `b[0][0] = 100`을 하면 `a[0][0]`도 함께 변경됩니다.


```python
a = [[1, 2], [3, 4]]

# 새로 복사된 리스트 b를 직접 만듭니다
b = []

# a의 첫 번째 줄을 복사해서 넣기
b.append([1, 2])

# a의 두 번째 줄을 복사해서 넣기
b.append([3, 4])

# 다시 한 번 같은 걸 복사해서 넣기
b.append([1, 2])
b.append([3, 4])

# b에서 첫 번째 줄의 첫 번째 숫자를 100으로 바꾸기
b[0][0] = 100

print(a)
print(b)
```
---
</> 예시코드:  리스트 길이 구하기 (len)
```python
fruits = ["banana", "mango", "peach"] 
print(len(fruits))
```

🖨️ 출력 결과:
```python
3
```

🔍 해설:
- `len()` 함수는 리스트에 몇 개의 요소가 있는지 알려줌
- 보통 반복문을 돌릴 때, 조건 검사할 때 많이 사용함

</> 예시코드: 중첩 리스트에서 `len()` 함수 사용하기
```python
classroom = [
    ["Alice", "Bob"],
    ["Charlie"],
    ["David", "Eve", "Frank"]
]

print(len(classroom))          # 전체 반의 수
print(len(classroom[2]))       # 세 번째 반의 학생 수
```

🖨️ 출력 결과:
```python
3
3
```

🔍 해설:
- `classroom`은 리스트 안에 리스트가 들어 있는 구조(중첩 리스트)입니다.
- `len(classroom)`은 전체 반(리스트)의 개수 → 3개
- `len(classroom[2])`는 세 번째 반에 있는 학생 이름의 개수 → 3명
---
📝 문제 1] 아래 코드에서 `IndexError`가 발생하지 않도록 수정하고, 마지막 요소를 출력하세요.
```python
fruits = ["apple", "banana", "cherry"]
print(fruits[ len(fruits) ])
```

🖨️ 출력 결과:
```python
cherry
```

✅ 정답 코드:
```python
print(fruits[ len(fruits) - 1 ])  # 마지막 요소 접근
```

🔍 해설:
- `len(fruits)`에서 반환되는 값은 3입니다. 그러나 인덱스 `3`은 존재하지 않음 (`IndexError`)
- 리스트의 인덱스는 `0 ~ len(fruits) - 1` 이므로, `-1`을 빼줘야 마지막 요소에 접근 가능
---
📝 문제 2] 당신은 색깔 목록에서 사용자가 선택한 인덱스 번호에 따라 색상을 보여주는 프로그램을 만들고 있습니다.  
리스트에는 아래와 같은 색상이 저장되어 있습니다.
```python
colors = ["red", "green", "blue", "yellow"]
```
사용자에게 0부터 3 사이의 숫자를 입력받아 해당 색상을 출력하려고 합니다.  
단, 사용자가 0~3 이외의 숫자를 입력하면 `"존재하지 않는 인덱스입니다."` 라고 출력해야 합니다.  
IndexError가 발생하지 않도록 조건문을 사용하여 해결하세요.

🖨️ 출력 예시 1 (예시 입력: `2`):
```python
선택한 색상: blue
```

🖨️ 출력 예시 2 (예시 입력: 5):
```python
존재하지 않는 인덱스입니다.
```

✅ 정답 코드:
```python
colors = ["red", "green", "blue", "yellow"]
i = int(input("색상 번호를 입력하세요 (0~3): "))

if 0 <= i < len(colors):
    print("선택한 색상:", colors[i])
else:
    print("존재하지 않는 인덱스입니다.")
```

🔍 해설:
- `len(colors)`는 4이므로 유효한 인덱스는 `0`, `1`, `2`, `3`
- 조건문 `0 <= i < len(colors)`를 사용하면,  
    존재하지 않는 인덱스를 미리 걸러낼 수 있어 `IndexError`를 방지할 수 있습니다.
---
📝 문제 3] 리스트의 인덱스를 음수를 사용하여 300이 출력되게 프린트 함수를 완성하세요.
```python
nums = [100, 200, 300, 400]
print()
```

✅ 정답 코드:
```python
nums = [100, 200, 300, 400]
print(nums[-2])
```

🔍 해설:
- 파이썬 리스트는 음수 인덱스도 허용함
- `-1`은 마지막 요소, `-2`는 뒤에서 두 번째 요소  
    → `nums[-2]`는 `300`
---
📝 문제 4] 리스트 내부에 있는 문자열 각각의 인덱스를 이용해, 모든 단어의 첫 글자만 출력하세요.
```python
words = ["python", "list", "index", "error"]
```

🖨️ 출력 결과:
```python
p
l
i
e
```

```python
words = ["python", "list", "index", "error"]

if len(words) > 0:
	print(words[0][0]) # p

if len(words) > 1:
	print(words[1][0]) # l

if len(words) > 2:
	print(words[2][0]) # i

if len(words) > 3:
	print(words[3][0]) # e			
```
---
# 🔹 리스트 요소 추가: append( ), insert( )
	리스트 요소 추가는 리스트에 새로운 값을 넣는 방법입니다.  
	대표적으로 append()와 insert() 메서드를 사용합니다.

| 메서드            | 기능 설명                  |
| -------------- | ---------------------- |
| `append(x)`    | 리스트 맨 뒤에 x 추가          |
| `insert(i, x)` | i번째 위치에 x 삽입 (기존 값 밀림) |

◽ append( ) 함수
	`append()`는 리스트의 마지막에 새로운 요소를 추가할때 사용합니다. 
	형식: `리스트.append(요소)`

</> 예시코드: `append()`로 맨 끝에 요소 추가하기
``` python
numbers = [1, 2, 3]
numbers.append(4)
print(numbers)
```

🖨️ 출력 결과:
```python
[1, 2, 3, 4]
```

🔍 해설:
- 여러 개를 한 번에 추가하려면 `append([4, 5])`가 아닌 `extend()`나 `+` 연산이 필요하지만,  여기서는 하나씩 추가하는 방식을 배웁니다.

---
◽ insert( ) 함수
	리스트의 특정 위치(인덱스)에 새로운 요소를 삽입할 때 사용합니다.
	형식: `리스트.insert(인덱스, 요소)`

</> 예시코드: `insert()`로 원하는 위치에 삽입하기
```python
fruits = ["apple", "banana", "grape"] 
fruits.insert(1, "orange") 
print(fruits)
```

🖨️ 출력 결과:
```python
['apple', 'orange', 'banana', 'grape']
```

🔍 해설:
- `insert(1, "orange")`는 `"orange"`를 index 1 위치에 삽입
- 기존의 `"banana"`는 뒤로 밀려나서 `2번째` 위치가 됨

---
##### ◽ 리스트 연결 연산자와 요소 추가의 차이
	리스트에 새로운 값을 넣는 방법은 여러 가지가 있습니다. 
	그중 자주 혼동되는 것이 바로
	- append() 메서드
	- 리스트 연결 연산자 +
	두 방법 모두 리스트에 값을 추가할 수 있지만, 동작 방식은 매우 
	다릅니다.

</> 예시코드: `append()`는 리스트 안에 리스트를 통째로 넣음
```python
a = [1, 2] 
a.append([3, 4]) 
print(a)
```

🖨️ 출력 결과:
```python
[1, 2, [3, 4]]
```

🔍 해설:
- `append()`는 전체를 하나의 요소로 추가
- 즉, `[3, 4]`라는 리스트 그 자체가 한 칸으로 들어감
- 결과적으로 리스트 안에 리스트(중첩 리스트)가 생김

---
</> 예시코드: `+` 연산자는 두 리스트를 연결해서 새 리스트로 만듦
```python
b = [1, 2] 
b = b + [3, 4] 
print(b)
```

🖨️ 출력 결과:
```python
[1, 2, 3, 4]
```

🔍 해설:
- `+` 연산은 두 리스트를 이어 붙이는 것
- 결과는 새로운 리스트 → 원래 있던 리스트는 변하지 않고 새로운 리스트로 대체
- `[3, 4]`가 하나의 요소가 아니라, 개별 요소로 들어감
---
📝 문제1] 당신은 할 일 목록을 리스트로 만들고 있습니다.  
먼저 `["공부하기", "청소하기"]`라는 리스트가 있고,  여기에 `"운동하기"`라는 항목을 리스트의 마지막에 추가하려고 합니다.  어떤 함수를 사용해야 할까요? 
해당 코드를 작성하고 결과를 출력하세요.
```python
todo = ["공부하기", "청소하기"]
```

🖨️ 출력 결과:
```python
['공부하기', '청소하기', '운동하기']
```

✅ 정답:
```python
todo = ["공부하기", "청소하기"]
todo.append("운동하기")
print(todo)
```

🔍 해설:
-  `append()`는 리스트 끝에 요소 하나를 추가할 때 사용
- 기존 요소들은 그대로 있고, `"운동하기"`가 마지막에 붙음
---
📝 문제2] 도서 목록 `["책A", "책B", "책C"]`가 있을 때,  가장 앞에 `"신간도서"`를 삽입해서 우선순위를 높이려고 합니다.  어떻게 해야 `"신간도서"`가 가장 앞에 오게 될까요?
```python
books = ["책A", "책B", "책C"]
```

🖨️ 출력 결과:
```python
['신간도서', '책A', '책B', '책C']
```

✅ 정답 코드:
```python
books = ["책A", "책B", "책C"]
books.insert(0, "신간도서")
print(books)
```

🔍 해설:
- `insert(0, ...)`은 리스트의 0번째 자리에 삽입한다는 의미
- 나머지 요소들은 자동으로 한 칸씩 뒤로 밀림
---
📝 문제3] 다음 코드에서 `append()`와 `+` 연산자를 사용한 결과는 어떻게 다를까요?  코드를 실행한 후 `nums1`과 `nums2`의 결과를 비교해보세요.
```python
nums1 = [1, 2]
nums1.append([3, 4])

nums2 = [1, 2]
nums2 = nums2 + [3, 4]
```

🖨️ 출력 결과:
```python
append 결과: [1, 2, [3, 4]]
연결 연산자 결과: [1, 2, 3, 4]
```

🔍 해설:
- `append([3, 4])`는 리스트 자체를 한 덩어리로 추가
- `+ [3, 4]`는 리스트를 풀어서 이어붙임
- 따라서 `append` 결과는 중첩 리스트가 되고, `+`는 낱개 요소가 추가됨
---
📝 문제4] 사용자에게 3개의 영화 제목을 입력받아, 입력한 순서대로 리스트에 `insert()`를 사용해 항상 맨 앞에 추가하려고 합니다.  
출력결과와 사용자 입력예시를 참고하여 코드를 작성하세요.

🖨️ 출력 결과:
```python
저장된 영화 목록: ['Terminator', 'Avatar', 'Titanic']
```

🖨️ 사용자 입력 예시:
```python
첫 번째 영화: Titanic  
두 번째 영화: Avatar  
세 번째 영화: Terminator
```

✅ 정답 코드:
```python
movies = []

movie1 = input("첫 번째 영화: ")
movies.insert(0, movie1) # 첫 번째 영화: Terminator

movie2 = input("두 번째 영화: ")
movies.insert(0, movie2) # 두 번째 영화: Avatar

movie3 = input("세 번째 영화: ")
movies.insert(0, movie3) # 세 번째 영화: Titanic

print("저장된 영화 목록:", movies)
```

🔍 해설:
- `insert(0, ...)`를 반복하면 새로운 입력이 항상 맨 앞에 쌓임
- 따라서 가장 마지막에 입력한 항목이 리스트의 맨 앞에 위치하게 됨

---
# 🔹 리스트 요소 제거하기
	리스트는 값을 추가하는 것뿐만 아니라, 필요 없는 값을 제거할 수도 
	있습니다.  
	예를 들어, 잘못 들어간 데이터를 빼거나, 사용한 값을 삭제하는 등  
	데이터를 유지보수하거나 정리할 때 꼭 필요한 기능이에요.

리스트에서 요소를 제거하는 방법은 여러 가지가 있는데,  
이번에는 인덱스를 기준으로 요소를 제거하는 방법을 알아보겠습니다.

##### ◽  `del` 키워드란?
	del은 파이썬의 삭제 전용 키워드로, 리스트에서 특정 위치(index)의 
	값을 제거할 때 사용합니다.

</> 예시코드:  del로 리스트 요소 삭제
```python
nums = [10, 20, 30, 40] 

del nums[1] 
print(nums)
```

🖨️ 출력 결과:
```python
[10, 30, 40]
```

🔍 해설:
- `nums[1]` 위치의 값인 `20`이 삭제됨 
- 삭제된 자리는 사라지고, 나머지 값들이 앞으로 당겨짐
- 리스트 자체가 바로 바뀜 (in-place)
---
##### ◽ `pop()` 메서드란?
	pop()은 리스트에서 특정 위치의 값을 꺼내서 삭제합니다.  
	삭제와 동시에 그 값을 반환(돌려줌)하는 기능이 있어요.
	
- 아무 것도 쓰지 않으면 마지막 요소를 제거
- `pop(index)`처럼 쓰면 해당 인덱스의 요소를 제거

</> 예시코드:  pop( )으로 마지막 요소 제거
```python
letters = ['a', 'b', 'c'] 
removed = letters.pop() 

print("삭제된 값:", removed) 
print("남은 리스트:", letters)
```

🖨️ 출력 결과:
```python
삭제된 값: c   
남은 리스트: ['a', 'b']
```

</> 예시코드:  pop(index)로 중간 요소 제거
```python
letters = ['a', 'b', 'c'] 
letters.pop(0) 
print(letters)
```

🖨️ 출력 결과:
```python
['b', 'c']
```

🔍 해설:
- `pop(0)` → 0번 인덱스의 `'a'`를 제거함
- `pop()`은 삭제한 값을 되돌려받을 수 있다는 점이 `del`과 차이점

---
##### ◽값으로 제거하기 : remove( )
	리스트에서 특정값 하나를 제거합니다. 가장먼저 나오는 값 하나만 제거됨

</> 예시코드:
```python
fruits = ["apple", "banana", "apple", "cherry"]
fruits.remove("apple")
print(fruits)
```

🖨️ 출력 결과:
```python
['banana', 'apple', 'cherry']
```

🔍 해설:
- `remove("apple")`은 리스트에서 첫 번째로 나오는 'apple'만 제거합니다.
- 나머지 `'apple'`은 그대로 유지됨.
- 만약 제거하려는 값이 리스트에 없으면 에러가 발생합니다.

---
##### ◽모두 제거하기: clear( )
	리스트 안의 모든 요소를 한 번에 제거합니다.  
	(리스트는 남고, 내용만 비워짐)

</> 예시코드:
```python
numbers = [1, 2, 3, 4]
numbers.clear()
print(numbers)
```

🖨️ 출력 결과:
```python
[]
```

🔍 해설:
- `clear()`는 리스트를 비우는 함수입니다.
- 리스트 객체는 그대로 있지만, 요소가 모두 삭제되어 빈 리스트가 됩니다.
- 나중에 다시 `append()`로 요소를 추가할 수 있습니다.

---
##### ◽ 리스트 간 빼기는 안 됨 ❌
```python
a = [1, 2, 3]
b = [2, 3]
print(a - b)
```

🛑 🖨️ 출력 결과:
```python
TypeError: unsupported operand type(s) for -: 'list' and 'list'
```

🔍 해설:
- 리스트끼리 `-` 연산은 안 됩니다
- 파이썬은 리스트 간 빼기를 직접 지원하지 않음

---
##### ◽ 리스트에서 값을 뺀 결과를 새로 만들기 (값 변경)
```python
a = [10, 20, 30]
b = [a[0] - 5, a[1] - 5, a[2] - 5]
print(b)
```

🖨️ 출력 결과:
```python
[5, 15, 25]
```

🔍 해설:
- 리스트 `a`의 각 요소에서 5씩 빼서 새로운 리스트 `b`를 만든 것
---
📝 문제1] 당신은 숫자 리스트 `[10, 20, 30, 40, 50]`에서  세 번째 값(`30`)을 인덱스를 이용해 삭제하려고 합니다.  
`del` 키워드를 사용해 코드를 작성하고, 최종 리스트를 출력해보세요.
```python
nums = [10, 20, 30, 40, 50]
```

🖨️ 출력 결과:
```python
[10, 20, 40, 50]
```

✅ 정답:
```python
nums = [10, 20, 30, 40, 50]
del nums[2]
print(nums)
```

🔍 해설:
- `del`은 인덱스로 삭제할 때 사용
- `nums[2]`는 `30`이므로 삭제되고, 나머지 값들이 앞으로 당겨짐

---
📝 문제2] 과일 리스트 `["apple", "banana", "cherry", "banana"]`에서  
처음 나오는 `"banana"` 하나만 삭제하려고 합니다.  값으로 삭제하는 방법을 사용하세요.

🖨️ 출력 결과:
```python
['apple', 'cherry', 'banana']
```

✅ 정답:
```python
fruits = ["apple", "banana", "cherry", "banana"]
fruits.remove("banana")
print(fruits)
```

🔍 해설:
-  `remove("banana")`는 처음 나타나는 `"banana"`만 삭제
- 나중에 나오는 `"banana"`는 그대로 남아 있음

---
📝 문제3] 다음 코드는 `pop()`을 사용하여 마지막 값을 꺼내고,  그 값을 따로 저장한 후 출력한 후  리스트도 출력해보세요.
리스트: `[100, 200, 300]`  
마지막 값을 꺼내고, 꺼낸 값과 리스트의 상태를 출력해보세요.
```python
scores = [100, 200, 300]
```

🖨️ 출력 결과:
```python
꺼낸 점수: 300
남은 점수: [100, 200]
```

✅ 정답:
```python
scores = [100, 200, 300]
last_score = scores.pop()
print("꺼낸 점수:", last_score)
print("남은 점수:", scores)
```

🔍 해설:
-  `pop()`은 삭제 + 반환
- 꺼낸 값을 따로 저장할 수 있어 이후에도 사용할 수 있음

---
📝 문제 4] 리스트에 여러 개의 데이터를 저장한 후,  모든 요소를 한꺼번에 비우고 싶습니다. `clear()` 함수를 사용해 리스트를 완전히 초기화하세요.
```python
data = ["python", "java", "c++"]
```

🖨️ 출력 결과:
```python
초기화된 리스트: []
```

✅ 정답:
```python
data = ["python", "java", "c++"]
data.clear()
print("초기화된 리스트:", data)
```

🔍 해설:
- `clear()`는 리스트를 완전히 비움
- 리스트 객체는 그대로 있고, 요소만 없어져 빈 리스트가 됨
---
# 🔹 리스트 정렬하기: sort( )
	리스트에 들어 있는 숫자나 글자들을 순서대로 정렬하고 싶을 때  
	파이썬에서는 sort() 메서드를 사용합니다.
	sort()는 리스트를 오름차순(작은 값 → 큰 값)으로 정렬하며,  
	원한다면 내림차순(큰 값 → 작은 값)으로도 바꿀 수 있어요.
	sort()는 리스트 안에 있는 값들의 순서를 정리해주는 도구입니다.

📖 문법, 구문(syntax)
```python
리스트.sort()  # 오름차순 정렬
리스트.sort(reverse=True) # 내림차순 정렬
```

###### ◽ 정렬 순서 
| 종류  | 예시 문자       | 유니코드 순서     | 정렬 위치 |
| --- | ----------- | ----------- | ----- |
| 숫자  | `'0'`~`'9'` | U+0030~0039 | 가장 앞  |
| 대문자 | `'A'`~`'Z'` | U+0041~005A | 그 다음  |
| 소문자 | `'a'`~`'z'` | U+0061~007A | 그 다음  |
| 한글  | `'가'`~      | U+AC00~     | 가장 뒤  |

```python
mixed = ["apple", "Apple", "가나다", "Banana", "banana", "123", "Zebra", "zoo", "가방", "100", "10"]

mixed.sort()
print(mixed)
```

🖨️ 출력 결과:
```python
['10', '100', '123', 'Apple', 'Banana', 'Zebra', 'apple', 'banana', 'zoo', '가나다', '가방']
```

🔍 해설:
- 숫자 문자열 `'10'`, `'100'`, `'123'` 가장 먼저 정렬됨 
- 대문자 문자열 `'Apple'`, `'Banana'`, `'Zebra'`
- 소문자 문자열 `'apple'`, `'banana'`, `'zoo'`
- 한글 문자열 `'가나다'`, `'가방'`
    가장 마지막에 정렬됨 (한글의 유니코드가 가장 크기 때문)

</> 예시코드: 내림차순 정렬
```python
mixed = ["apple", "Apple", "가나다", "Banana", "banana", "123", "Zebra", "zoo", "가방", "100", "10"]
mixed.sort(reverse = True)
print(mixed)
```

🖨️ 출력 결과:
```python
['가방', '가나다', 'zoo', 'banana', 'apple', 'Zebra', 'Banana', 'Apple', '123', '100', '10']
```

🔍 해설:
- `reverse=True`를 주면 유니코드 순서의 역방향으로 정렬됩니다.
- 즉, 유니코드 값이 큰 것부터 작은 것 순서로 나열됩니다.

정렬 순서 (내림차순일 때):
1. 한글 → 유니코드 값이 가장 큼 → 제일 앞에 정렬
2. 소문자 (`zoo`, `banana`, `apple`)
3. 대문자 (`Zebra`, `Banana`, `Apple`)
4. 숫자 문자열 (`123`, `100`, `10`) → 유니코드상 가장 작으므로 마지막
---
###### ◽  `sort()` vs `sorted()`
| 함수 이름      | 원본 리스트 <br>변경 여부 | 반환값                | 사용 목적                          |
| ---------- | ---------------- | ------------------ | ------------------------------ |
| `sort()`   | 원본을 직접 변경        | None 변수에 <br>저장 불가 | 리스트 자체를 정렬하고 싶을 때              |
| `sorted()` | 원본은 그대로 유지       | 새로운 리스트 반환         | 원본은 그대로 두고 정렬 결과만 따로 저장하고 싶을 때 |
</> 차이를 보여주는 예시코드:
```python
original = ["banana", "Apple", "가나다", "123", "apple", "Zebra", "가방", "10"]
new_sorted = sorted(original)

print("원본 리스트:", original)
print("정렬된 새 리스트:", new_sorted)
```

🖨️ 출력 결과:
```python
원본 리스트: ['banana', 'Apple', '가나다', '123', 'apple', 'Zebra', '가방', '10']
정렬된 새 리스트: ['10', '123', 'Apple', 'Zebra', 'apple', 'banana', '가나다', '가방']
```

🔍 해설:
- `sorted(original)`은 원본을 변경하지 않음
    - `original`은 그대로 유지
- 정렬 기준은 유니코드 순서
    - `숫자 문자열` → `'10'`, `'123'`이 가장 앞
    - `대문자` → `'Apple'`, `'Zebra'`
    - `소문자` → `'apple'`, `'banana'`
    - `한글` → `'가나다'`, `'가방'`이 가장 뒤
- 새로 만들어진 리스트 `new_sorted`는 정렬된 결과를 담고 있음
---
###### ◽ `sorted( )`함수

📖 문법, 구문(syntax): 
```python
sorted(리스트, key=정렬기준함수)
```

###### ◽ `key` 매개변수란?
	정렬 함수(`sorted()`, `sort()`)에서 정렬 기준을 내 마음대로 설정
	할 수 있게 해주는 옵션입니다.

###### ◽ 자주 쓰는 `key` 함수 예시
| `key` 값              | 설명                          | 예시 결과                        |
| -------------------- | --------------------------- | ---------------------------- |
| `key=str.lower`      | 모두 소문자로 변환해 비교 (대소문자 무시 정렬) | "apple", "Apple" 순서 통일       |
| `key=str.upper`      | 모두 대문자로 변환해 비교              | 대소문자 구분 없이 정렬                |
| `key=len`            | 요소의 길이를 기준으로 정렬             | 문자열 길이 순 정렬                  |
| `key=int`            | 숫자형 문자열을 숫자로 변환해 정렬         | `"10"`과 `"2"` 비교 시 `"2"`가 먼저 |
| `key=lambda x: x[1]` | 튜플의 두 번째 요소 기준으로 정렬         | `(a, 2)`의 `2` 기준 정렬          |

---
</> 예시코드: `key=str.lower` – 대소문자 구분 없이 정렬
```python
names = ["banana", "Apple", "cherry", "apple"]
names.sort(key=str.lower)
print(names)
```

🖨️ 출력 결과:
```python
['Apple', 'apple', 'banana', 'cherry']
```

🔍 해설:
- `str.lower`는 모든 값을 소문자로 변환해서 비교
- 하지만 출력 결과는 원래 대소문자 그대로 유지
- `'Apple'`과 `'apple'`은 비교 기준으로 같지만, 원래 순서대로 정렬됨
---
</> 예시코드: `key=len` – 길이 기준 정렬
```python
words = ["dog", "elephant", "cat", "tiger"]
words.sort(key=len)
print(words)
```

🖨️ 출력 결과:
```python
['dog', 'cat', 'tiger', 'elephant']
```

🔍 해설:
- 각 단어의 길이(`len`)를 기준으로 정렬
- 길이가 짧은 단어부터 긴 단어 순으로 나열됨
---
</> 예시코드:  `key=int` – 숫자 문자열을 실제 숫자처럼 정렬
```python
nums = ["10", "2", "30", "1"]
nums.sort(key=int)
print(nums)
```

🖨️ 출력 결과:
```python
['1', '2', '10', '30']
```

🔍 해설:
- 문자열이지만 `int`로 변환해서 숫자처럼 정렬
- 일반 문자열 정렬이면 `"10"`이 `"2"`보다 앞에 와야 하지만,  
    `int`를 쓰면 실제 숫자값 10과 2를 비교함
---
</> 예시코드: `key=lambda x: x[1]` – 튜플의 두 번째 값 기준 정렬
```python
students = [("민수", 85), ("영희", 95), ("철수", 90)]
students.sort(key=lambda x: x[1])
print(students)
```

🖨️ 출력 결과:
```python
[('민수', 85), ('철수', 90), ('영희', 95)]
```

🔍 해설:
- 각 튜플의 두 번째 값(점수)을 기준으로 오름차순 정렬
- `lambda x: x[1]`는 `요소x = ("민수", 85)`  `x[1] 값 = 85` 이 뜻으로 점수기준으로 정렬하겠다는 뜻입니다.
---
</> 예시코드: `ey=lambda x: x[::-1]` – 문자열을 뒤집은 값 기준 정렬
```python
words = ["abc", "xyz", "bca", "cab"]
words.sort(key=lambda x: x[::-1])
print(words)
```

🖨️ 출력 결과:
```python
['bca', 'cab', 'abc', 'xyz']
```

◽ 순차적으로 단계처리과정
✅ 1단계: 각 요소를 거꾸로 만들기
```python
words = ["abc", "xyz", "bca", "cab"]

"abc" -> "cba"
"xyz" -> "zyx"
"bca" -> "acb"
"cab" -> "bac"
```

✅ 2단계:  뒤집은 값을 기준으로 알파벳 오름차순 정렬
```python
words = ["abc", "xyz", "bca", "cab"]

"abc" -> "bca"
"bca" -> "cab"
"cab" -> "abc"
"xyz" -> "xyz"

# 정렬기준 
"acb" < "bac" < "cba" < "zyx"
```

✅ 3단계: 최종결과
```python
["bca", "cab", "abc", "xyz"]
```

🔍 해설:
- 리스트 words를 정렬하되 각 단어를 거꾸로 뒤집은 값을 기준으로 정렬됩니다.
- 1차 원래단어를 뒤집고
- 2차 뒤집힌 값들을 알파벳 순으로 정렬합니다.
- `lambda x: x[::-1]`는 단어를 거꾸로 만드는 함수로 단어를 뒤집은 결과 기준으로 정렬됩니다.
- 그래서 단순히 `["abc", "bca", "cab", "xyz"]` 이렇게 정렬되지 않고 거꾸로 봤을때 순서대로 정렬됩니다.
---
◽ 정렬 기준 1 : 문자열을 거꾸로
```python
lambda x: x[::-1]
```

- `"abc"[::-1]` → `"cba"`
- `"cat"[::-1]` → `"tac"`
즉, 문자열을 뒤에서부터 정렬하는 느낌입니다.

◽ 정렬 기준 2 : 문자열을 거꾸로
```python
lambda x: x[-1]
```

- `"abc"[-1]` → `"c"`
- `"cat"[-1]` → `"t"`
즉, 각 단어의 마지막 글자만 보고 정렬하는 기준입니다.

</>예시코드
```python
words = ["dog", "cat", "bat", "ant"]

# 기준 1: 문자열을 거꾸로 정렬
print(sorted(words, key=lambda x: x[::-1]))

# 기준 2: 마지막 글자 기준 정렬
print(sorted(words, key=lambda x: x[-1]))
```

✅ 정답 코드:
```python
words = ["dog", "cat", "bat", "ant"]

print("::-1 =",sorted(words, key=lambda x: x[::-1]))#문자열을 뒤집은 값을 기준으로 정렬
print("-1 =",sorted(words, key=lambda x: x[-1]))  # 문자열의 마지막 글자를 기준으로 정렬
```

🖨️ 출력 결과:
```python
::-1 = ['dog', 'bat', 'cat', 'ant']
-1 = ['dog', 'cat', 'bat', 'ant']
```
---
◽ `x[::-1]` → 문자열 뒤집기 기준
```python
words = ["dog", "cat", "bat", "ant"]

"dog" →	"god"
"cat" →	"tac"
"bat" →	"tab"
"ant" →	"tna"
```

◽ 이걸 알파벳 순으로 정렬하면:
```python
"god" → "dog"
"tab" → "bat"
"tac" → "cat"
"tna" → "ant"

# 결과
::-1 = ['dog', 'bat', 'cat', 'ant']
```
---
◽ `x[-1]` → 마지막 글자 기준
```python
words = ["dog", "cat", "bat", "ant"]

"dog" →	"g"
"cat" →	"t"
"bat" →	"t"
"ant" →	"t"

정렬기준: "g", "t", "t", "t"
정렬 순서: "dog" < "cat" < "bat" < "ant"
같은 기준값 ("t")을 가진 경우에는 리스트 안에서의 원래 순서를 유지합니다.
이것을 안정정렬(stable sort)라고 합니다.

# 결과
-1 = ['dog', 'cat', 'bat', 'ant']
```
---
📝 문제 1] 문자열을 거꾸로 뒤집은 값을 기준으로 정렬하기
`fruits = ["pear", "apple", "plum", "grape"]`  
각 단어를 거꾸로 뒤집은 값을 기준으로 오름차순 정렬하세요.

🖨️ 출력 결과:
```python
['apple', 'grape', 'plum', 'pear']
```

✅ 정답 코드:
```python
fruits = ["pear", "apple", "plum", "grape"]
result = sorted(fruits, key=lambda x: x[::-1])
print(result)
```

◽ 과일이름 뒤집기
```python
"pear" → "raep"
"apple" → "elppa"
"plum" → "mulp"
"grape" → "eparg"
```

◽ 뒤집어진 문자열들을 알파벳 순으로 정렬하면:
```python
"elppa" - e로 시작 
"eparg" - e로 시작
"mulp" - m으로 시작
"raep" - r로 시작
```

◽ 최종결과:
```python
['apple', 'grape', 'plum', 'pear']
```
---
📝 문제 2] 마지막 글자 기준으로 정렬하기
`animals = ["tiger", "dog", "bear", "goat"]`  
각 단어의 마지막 글자를 기준으로 정렬한 결과를 출력하세요.

✅ 정답 코드:
```python
animals = ["tiger", "dog", "bear", "goat"]
result = sorted(animals, key=lambda x: x[-1])
print(result)
```

🖨️ 출력 결과:
```python
['dog', 'tiger', 'bear', 'goat']
```

```python
단어	     마지막 글자 (x[-1])
"tiger"	 "r"
"dog"	 "g"
"bear"	 "r"
"goat"	 "t"
```
---
# 🔹 in / not in 연산자
	리스트 안에 특정 값이 들어있는지 확인하고 싶을 때, 파이썬에서는 
	in 연산자 또는 not in 연산자를 사용합니다.
	"값 in 리스트" → 값이 리스트 안에 있으면 True, 없으면 False  
	"값 not in 리스트" → 값이 리스트 안에 없으면 True

📖 문법, 구문(syntax): 
```python
값 in 리스트       # 값이 들어 있으면 True 
값 not in 리스트   # 값이 없으면 True
```

</> 예시코드: 값이 리스트에 있는 경우
```python
fruits = ["apple", "banana", "cherry"] 
print("banana" in fruits)
```

🖨️ 출력 결과:
```python
True
```

</> 예시코드:  값이 리스트에 없는 경우
```python
numbers = [1, 2, 3] 

print(5 in numbers) 
print(5 not in numbers)
```

🖨️ 출력 결과:
```python
False 
True
```

🔍 해설:
- `5`는 리스트 안에 없으므로 `in`은 `False`, `not in`은 `True`
---
</> 예시코드:  조건문과 함께 사용
```python
colors = ["red", "blue", "green"] 

if "green" in colors:     
	print("green이 포함되어 있어요!")
```

🖨️ 출력 결과:
```python
green이 포함되어 있어요!
```

🔍 해설:
- `"green"`이 리스트에 있는지 확인한 후 메시지 출력
- 이런 방식은 검색 기능, 필터링, 중복 확인 등에 활용 가능
---
📝 문제1] 사용자에게 동물 이름을 입력받아, 리스트에 있는지 검사한 후 결과를 출력하세요.

단, 입력값의 대소문자는 구분하지 않고 비교하세요.
```python
animals = ["cat", "dog", "bird", "rabbit"] 
```

🖨️ 출력 결과:
```python
리스트에 있습니다!
```

✅ 정답 코드:
```python
animals = ["cat", "dog", "bird", "rabbit"]
word = input("동물 이름을 입력하세요: ")

if word.lower() in animals:
    print("리스트에 있습니다!")
else:
    print("리스트에 없습니다.")
```

🔍 해설:
	사용자의 입력값이 `"Dog"`처럼 대문자를 포함하더라도, `lower()`로 소문자로 바꿔 비교하면 리스트 안의 `"dog"`과 일치 가능

---
📝 문제2] 리스트 `["red", "blue"]`에 `"green"`이 없을 때만 `"green 없음"`을 출력해보세요.

🖨️ 출력 결과:
```python
green 없음
```

✅ 정답 코드:
```python
colors = ["red", "blue"]  

if "green" not in colors:     
	print("green 없음")
```

🔍 해설:
- `"green"`은 리스트에 없기 때문에 `not in` 조건이 `True`가 되어 출력됨
---
📝 문제3] 다음은 금지어가 있는 단어 리스트입니다.
사용자가 입력한 단어가 금지어 리스트에 없을 경우에만 `"사용 가능"`을 출력하세요.
```python
banned_words = ["badword", "uglyword", "hate"]
```

🖨️ 출력 결과(입력: hello):
```python
사용 가능
```

✅ 정답 코드:
```python
banned_words = ["badword", "uglyword", "hate"]
word = input("사용할 단어를 입력하세요: ")

if word not in banned_words:
    print("사용 가능")
else:
    print("금지된 단어입니다.")
```

---
# 🔹 for 반복문
	for 반복문은 리스트처럼 여러 개의 값이 들어 있는 자료형을 하나씩 
	꺼내서 사용할 때 사용하는 문법이에요.  
	반복문을 사용하면 코드를 반복해서 실행할 수 있어 아주 편리하고 
	강력합니다.
	
"리스트에 들어 있는 값들을 하나씩 꺼내서 반복 실행하는 구조"입니다.

📖 문법, 구문(syntax): 
```python
for 변수 in 리스트:     
	실행할 코드
```

- 리스트 안에 있는 값이 하나씩 `변수`에 들어가며 `코드 블록`이 실행됨
- 리스트에 값이 5개면 코드가 5번 실행됨
---
</> 예시코드: 대소문자 섞인 리스트에서 모두 소문자로 바꿔 출력하기
```python
colors = ["Red", "GREEN", "bLue", "YELLOW"]

for color in colors:
    print(color.lower())
```

🖨️ 출력 결과:
```python
red  
green  
blue  
yellow
```

🔍 해설:
- `str.lower()`를 사용하여 대소문자 섞인 값을 모두 소문자로 통일해 출력
- 문자열 전처리 시 자주 쓰이는 방식
---
</> 예시코드: 숫자 리스트 중 짝수만 2배로 출력, 나머지는 무시
```python
nums = [4, 7, 10, 3, 8]

for n in nums:
    if n % 2 == 0:
        print(n * 2)
```

🖨️ 출력 결과:
```python
8  
20  
16
```

🔍 해설:
-  짝수만 필터링 (`n % 2 == 0`)
- 짝수일 경우에만 2배로 곱해서 출력
- 실무에서도 데이터 필터링 시 자주 사용
---
</> 예시코드: 음식 리스트에서 'bread'가 포함된 항목만 영어 문장으로 출력
```python
foods = ["banana bread", "rice", "bread", "noodles", "garlic bread"]

for food in foods:
    if "bread" in food:
        print(f"{food} contains bread!")
```

🖨️ 출력 결과:
```python
banana bread contains bread!  
bread contains bread!  
garlic bread contains bread!
```

🔍 해설:
- 리스트에서 꺼낸 문자열 `food`를 활용해 문장을 만들어 출력
---
</> 예시코드: 문자열 리스트의 첫 글자만 모아서 새 리스트로 만들기
```python
names = ["Alice", "Bob", "Michael", "Diana"]
first_letters = []

for name in names:
    first_letters.append(name[0])

print(first_letters)
```

🖨️ 출력 결과:
```python
['A', 'B', 'M', 'D']
```

🔍 해설:
- 문자열 인덱싱으로 첫 글자 추출
- 추출된 값을 다른 리스트에 저장
- 리스트 변환과 축약에 유용한 방식

---
📝 문제1] 숫자 리스트에서 3의 배수만 출력하세요.
```python
nums = [4, 6, 7, 9, 12, 15, 18]
```

✅ 정답 코드:
```python
nums = [4, 6, 7, 9, 12, 15, 18]

for n in nums:
    if n % 3 == 0:
        print(n)
```

🔍 해설:
- `n % 3 == 0` 조건으로 3의 배수만 필터링하여 출력
---
📝 문제2] 동물 리스트에 대해 `"I like ___"` 형식으로 출력하되,
"cat"일 때만 "I love cat" 이라고 출력하세요.
```python
animals = ["dog", "cat", "fox"]
```

🖨️ 출력 결과:
```python
I like dog  
I love cat  
I like fox
```

✅ 정답 코드:
```python
animals = ["dog", "cat", "fox"]

for animal in animals:
    if animal == "cat":
        print("I love cat")
    else:
        print("I like " + animal)
```

🔍 해설:
- 특정 값("cat")일 때만 예외 처리
- `if-else` 조건문을 반복문 안에 사용
----
# 🔹 for 반복문: 리스트와 함께 사용하기
	for 반복문은 리스트와 함께 쓰면 가장 강력한 기능을 발휘해요.  
	리스트에 들어 있는 값들을 하나씩 꺼내며 반복 처리하기 때문에  
	정해진 데이터들을 순서대로 처리할 때 꼭 필요한 문법입니다.

</> 예시코드: 과일 리스트를 출력하기
```python
fruits = ["apple", "banana", "cherry"]

for fruit in fruits:
    print(fruit.upper())
```

🖨️ 출력 결과:
```python
APPLE  
BANANA  
CHERRY
```

🔍 해설:
- `for fruit in fruits:` → 리스트 요소만 순차적으로 가져옴
- `fruit.upper()` → 대문자로 변환하여 출력

---
</> 예시코드:  리스트 값 변형 + 조건문 + 새 리스트 생성
```python
scores = [70, 80, 90]
adjusted_scores = []

for score in scores:
    new_score = score + 10 # new_score = 80 90 100
    adjusted_scores.append(new_score) 

for score in adjusted_scores:
    if score >= 90:
        print(f"{score}점 (우수)")
    else:
        print(f"{score}점 (보통)")
```
---
`리스트이름.append(값)` 문법구조
- `adjusted_scores` : 리스트 빈그릇
- `append()` : 리스트에 값을 하나 추가하는 함수 (뒤에 붙임)
- `new_score` : 추가할 값 (변수든 숫자든 문자열이든 가능)
---
🖨️ 출력 결과:
```python
80점 (보통)
90점 (우수)
100점 (우수)
```

🔍 해설:
- `scores` 리스트에는 원래 점수들이 저장되어 있습니다.
- 첫 번째 `for`문은 각 점수에 10점을 더해서 `new_score`를 만든 뒤, `adjusted_scores`라는 새로운 리스트에 저장합니다.
- 두 번째 `for`문은 `adjusted_scores` 리스트를 순회하면서 점수가 90 이상이면 `(우수)`, 그렇지 않으면 `(보통)`이라고 출력합니다.
- 이 과정에서 리스트를 가공하고, 조건에 따라 다르게 출력하는 연습까지 포함되어 있어 `for + 리스트 활용`에 대한 이해를 심화시킬 수 있습니다.
---
</> 예시코드: 고객 데이터 기반 환영 메시지 생성기
```python
customer_names = ["홍길동", "김미정", "이수현", "박", "최민수"]

welcome_messages = []

for name in customer_names:
    name_length = len(name) -> 3
    first_char = name[0] -> "홍"
	
    if name_length <= 2:
        message = f"{name}님, 짧고 기억하기 쉬운 이름이네요!"
    elif name_length == 3:
        message = f"{name}님, 안정적인 세글자의 이름이시군요!"
    else:
        message = f"{name}님, 정중한 인상을 주는 이름이시군요."
		
    welcome_messages.append({
        "customer": name,
        "message": message,
        "first_letter": first_char,
        "name_length": name_length
    })
		
for entry in welcome_messages:
    print(f"[고객: {entry['customer']}] → {entry['message']}")
```
---
✅ 내부 작동순서
 메모리에 리스트 생성
```python
customer_names = ["홍길동", "김미정", "이수현", "박", "최민수"]
welcome_messages = []
```

 `for name in customer_names:` 반복 시작
- 파이썬은 `customer_names` 리스트의 요소를 하나씩 꺼내며 반복 실행합니다.

🔄 1회차 (name = "홍길동")
```python
name_length = len(name)
	- len("홍길동") → 3   
	- 정수 3이 name_length 변수에 저장됨
    
first_char = name[0]
	- 문자열 인덱싱: "홍길동"[0] → '홍'
	- 문자 '홍'이 first_char 변수에 저장됨
```

조건문실행
```python
if name_length <= 2:       → False
elif name_length == 3:     → True 
```
→ `message` 변수에  
`"홍길동님, 안정적인 세글자의 이름이시군요!"` 저장됨

`append()` 딕셔너리 객체 생성
```python
{
  "customer": "홍길동",
  "message": "홍길동님, 안정적인 세글자의 이름이시군요!",
  "first_letter": "홍",
  "name_length": 3
}
```
- 이 딕셔너리를 `welcome_messages` 리스트에 **추가** (`append` 호출)

🔁 최종 출력 루프
```python
for entry in welcome_messages:
    print(f"[고객: {entry['customer']}] → {entry['message']}")
```
- 리스트 `welcome_messages`를 하나씩 순회하며,
- 각 `entry` 딕셔너리에서 `['customer']`, `['message']` 값을 꺼내
- `print()`를 통해 출력

🖨️ 출력 결과:
```python
[고객: 홍길동] → 홍길동님, 안정적인 세글자의 이름이시군요!
[고객: 김미정] → 김미정님, 안정적인 세글자의 이름이시군요!
[고객: 이수현] → 이수현님, 안정적인 세글자의 이름이시군요!
[고객: 박] → 박님, 짧고 기억하기 쉬운 이름이네요!
[고객: 최민수] → 최민수님, 안정적인 세글자의 이름이시군요!
```

---
📝 문제1] 아래 리스트의 모든 문자에 `"는 알파벳입니다"`라는 문장을 붙여 출력하세요.

단, 모든 문자는 대문자로 출력되도록 하세요.
```python
letters = ["a", "b", "c"]
```

🖨️ 출력 결과:
```python
A는 알파벳입니다  
B는 알파벳입니다  
C는 알파벳입니다
```

✅ 정답 코드:
```python
letters = ["a", "b", "c"]

for ch in letters:
    print(ch.upper() + "는 알파벳입니다")
```

🔍 해설:
- `upper()`를 활용해 소문자를 대문자로 변환
- 문자열 덧셈으로 문장을 완성
---
📝 문제2] 리스트에 저장된 숫자를 반복문으로 출력하되,
짝수는 `[짝수]`, 홀수는 `(홀수)` 형식으로 출력하세요.
```python
employee_ids = [101, 102, 103, 104]
```

🖨️ 출력 결과:
```python
(101)  
[102]  
(103)  
[104]
```

✅ 정답 코드:
```python
employee_ids = [101, 102, 103, 104]

for eid in employee_ids:
    if eid % 2 == 0:
        print(f"[{eid}]")  # 정규직
    else:
        print(f"({eid})")  # 계약직
```

🔍 해설:
- `eid % 2 == 0`: 직원 ID가 짝수이면 정규직
- `else`: 홀수이면 계약직
- 조건문으로 출력 형식을 분기해서 구분된 메시지를 출력
---
📝 문제3] 사용자 이름 리스트가 주어졌을 때,

고객 이름 리스트가 주어졌습니다.
- 이름 길이에 따라 사용자 등급을 분류하세요.
    - 2글자 이하: `"단명 사용자"`
    - 3글자: `"일반 사용자"`
    - 4글자 이상: `"프리미엄 사용자"`

- 출력 형식은 아래와 같이 구성하세요:  
    이름 (글자 수) → 사용자 등급
```python
names = ["유나", "정우", "세바스찬", "김재민", "수"]
```

🖨️ 출력 결과:
```python
유나 (2글자) → 단명 사용자  
정우 (2글자) → 단명 사용자  
세바스찬 (4글자) → 프리미엄 사용자  
김재민 (3글자) → 일반 사용자  
수 (1글자) → 단명 사용자
```

✅ 정답 코드:
```python
names = ["유나", "정우", "세바스찬", "김재민", "수"]

for name in names:
    length = len(name)

    if length <= 2:
        level = "단명 사용자"
    elif length == 3:
        level = "일반 사용자"
    else:
        level = "프리미엄 사용자"

    print(f"{name} ({length}글자) → {level}")
```

🔍 해설:
- `len()`으로 글자 수를 구하고
- 조건문으로 길이가 3 이상인 경우 추가 메시지를 출력
---
# 🔹 중첩 리스트와 중첩 반복문
	리스트 안에 또 다른 리스트가 들어 있는 구조를 중첩 리스트
	(nested list)라고 합니다.  
	이때, 안쪽 리스트의 값을 다루기 위해서는 반복문을 반복문 안에 넣는 
	중첩 반복문을 사용합니다.

리스트가 2차원 표처럼 행과 열로 구성되어 있을 때,  
for문을 두 번 써서 각 값을 꺼내는 방법이 바로 중첩 반복문입니다.

📖 문법, 구문(syntax): 
```python
list_of_list = [
    [1, 2, 3],      # 첫 번째 행 (리스트)
    [4, 5, 6, 7],   # 두 번째 행
    [8, 9]          # 세 번째 행
]
```

- `list_of_list` 는 3개의 리스트를 요소로 가진 리스트 → 3행 다열 구조
- `list_of_list[0]` → `[1, 2, 3]`
- `list_of_list[0][1]` → `2` (0번째 줄의 1번째 값)

---
</> 예시코드: 중첩 리스트 내부 리스트 출력하기
```python
list_of_list = [
    [1, 2, 3],      
    [4, 5, 6, 7],   
    [8, 9]         
] 

for items in list_of_list:
    print(items)
```

🖨️ 출력 결과:
```python
[1, 2, 3]
[4, 5, 6, 7]
[8, 9]
```

---
</> 예시코드:  중첩 반복문으로 내부 값 하나씩 출력하기
```python
list_of_list = [
    [1, 2, 3],      
    [4, 5, 6, 7],   
    [8, 9]         
] 

for items in list_of_list:  # 바깥 리스트에서 내부 리스트 하나씩 꺼냄
    for item in items:   # 내부 리스트에서 요소 하나씩 꺼냄
        print(item)
```

🖨️ 출력 결과:
```python
1
2
3
4
5
6
7
8
9
```

```python
for items in list_of_list: -> [1, 2, 3]
    for item in items:  1,2,3
        print(item) 1 2 3 출력

for items in list_of_list: -> [4, 5, 6, 7]
    for item in items:  4,5,6,7
        print(item) 4 5 6 7 출력

for items in list_of_list: -> [8, 9]
    for item in items:  8,9
        print(item) 8 9 출력
```

🔍 해설: 출력순서
- 첫번째 for문에서 중첩 리스트의 첫번째가 호출되고
- 두번째 for문에서 호출된 리스트가 다시 펼쳐져서 호출됩니다.
---
📝 문제1] 다음 중첩 리스트에서 숫자를 하나씩 출력하되, 짝수는 "짝수", 홀수는 "홀수" 라는 표시도 함께 출력하세요.
```python
nums = [     
	[1, 2, 3],     
	[4, 5, 6] 
]
```

🖨️ 출력 결과:
```python
1 → 홀수  
2 → 짝수  
3 → 홀수  
4 → 짝수  
5 → 홀수  
6 → 짝수
```

✅ 정답 코드:
```python
for row in nums:
    for num in row:
        if num % 2 == 0:
            print(f"{num} → 짝수")
        else:
            print(f"{num} → 홀수")
```

🔍 해설:
- `num % 2 == 0`을 통해 짝수/홀수를 판단합니다.
- 조건문을 통해 각 숫자의 속성을 문장으로 표현합니다.
---
📝 문제2] 다음 2차원 리스트에서 `"철수"`가 성인인지 확인하고, 출력 형식을 아래처럼 꾸며보세요.

출력 형식: `"철수님은 25세로 성인입니다."`  
성인은 나이가 20세 이상인 사람으로 간주합니다.
```python
people = [
    ["영희", 22],
    ["철수", 25],
    ["민수", 18]
]
```

🖨️ 출력 결과:
```python
영희님은 22세로 성인입니다.  
철수님은 25세로 성인입니다.  
민수님은 18세로 미성년자입니다.
```

✅ 정답 코드: 
```python
people = [
    ["영희", 22],
    ["철수", 25],
    ["민수", 18]
]

for person in people:
    name, age = person

    if age >= 20:
        status = "성인"
    else:
        status = "미성년자"

    print(f"{name}님은 {age}세로 {status}입니다.")
```

✅ 정답 코드: 삼항조건식으로 표현
```python
people = [
    ["영희", 22],
    ["철수", 25],
    ["민수", 18]
]

for person in people:
    name, age = person
    status = "성인" if age >= 20 else "미성년자"
    print(f"{name}님은 {age}세로 {status}입니다.")
```

🔍 해설:
- 리스트의 각 요소를 `name`, `age`로 언팩(분해)합니다.
- `삼항 조건식`을 사용해 성인/미성년자 판단 후 메시지를 출력합니다.
---
# 🔹 전개 연산자
	전개 연산자(spread operator)는 * 기호를 사용해 리스트나 튜플처럼 
	여러 개의 값이 들어 있는 자료를 하나하나 꺼내서 펼쳐주는 기호입니다.

"리스트 안에 있는 값들을 하나씩 꺼내서 펼쳐주는 도구"가 전개 연산자입니다.

---
###### ◽ 사용 위치에 따라 다른 역할
| 사용 위치             | 동작 예시               | 설명                |
| ----------------- | ------------------- | ----------------- |
| 함수 호출 시           | `print(*[1, 2, 3])` | 각각의 값으로 분해해서 전달   |
| 리스트 결합 시          | `[1, *[2, 3], 4]`   | 리스트 안 리스트를 펼쳐서 합침 |
| 함수 정의 시 (`*args`) | `def func(*args):`  | 여러 개 인자를 한 번에 받음  |

---
</> 예시코드: 리스트 안 값을 하나씩 꺼내 출력
```python
nums = [1, 2, 3] 
print(nums)
print(*nums)
```

🖨️ 출력 결과:
```python
[1, 2, 3]
1 2 3
```

🔍 해설:
- `*nums`는 리스트 `[1, 2, 3]`을 각각 `1`, `2`, `3`으로 분해
- `print()` 함수에 여러 인자를 넘기는 효과
- `print(nums)`와는 결과가 다름 → `print(nums)`는 `[1, 2, 3]` 전체 출력

---
</> 예시코드: 리스트 결합 시 중첩 없이 펼치기
```python
a = [1, 2]
b = [3, 4]

result1 = [*a, *b]
result2 = [a, b]

print(result1)
print(result2)
```

🖨️ 출력 결과:
```python
[1, 2, 3, 4]
[[1, 2], [3, 4]]
```

🔍 해설:
- `*a`는 리스트 `[1, 2]`의 요소를 풀어서 삽입
- 중첩 리스트 없이 하나의 리스트로 합쳐짐
---
</> 예시코드: 문자열도 전개 가능
```python
text = "abc"
print(text)
print(*text)
```

🖨️ 출력 결과:
```python
abc
a b c
```

🔍 해설:
- 문자열 `"abc"`도 반복 가능한 객체 → 각 문자로 분해 출력
---
</> 예시코드: 고객 주문 데이터를 병합하고 요약 출력하기
```python
# 매장별 오늘의 주문 리스트
orders_branch_A = ["김밥", "라면"]
orders_branch_B = ["떡볶이", "순대"]
orders_branch_C = ["김말이", "튀김"]

# 전부 합쳐서 본사 집계용 리스트로 생성
all_orders = [*orders_branch_A, *orders_branch_B, *orders_branch_C]

# 중복 제거 후 정렬
unique_orders = sorted(all_orders)

# 요약 출력
print(f"오늘 총 주문 건수: {len(all_orders)}건")
print(f"주문된 메뉴 목록 ({len(unique_orders)}종류):")
print(", ".join(unique_orders))
```

```python
orders_branch_A = ["김밥", "라면"]
orders_branch_B = ["떡볶이", "순대"]
orders_branch_C = ["김말이", "튀김"]

all_orders = [*orders_branch_A, *orders_branch_B, *orders_branch_C]
`all_orders` = ['김밥', '라면', '떡볶이', '순대', '김말이', '튀김']

unique_orders = sorted(all_orders)
`unique_orders` = ['김말이', '김밥', '떡볶이', '라면', '순대', '튀김'] 

print(f"오늘 총 주문 건수: {len(all_orders)}건") -> 6
print(f"주문된 메뉴 목록 ({len(unique_orders)}종류):") -> 6종류
print(", ".join(unique_orders)) -> 김말이, 김밥, 떡볶이, 라면, 순대, 튀김
```
- `", "` 각 요소 사이에 들어갈 문자열 (구분자)
- `.join([...])` 리스트의 요소를 하나씩 꺼내서 문자열로 연결


🖨️ 출력 결과:
```python
오늘 총 주문 건수: 6건
주문된 메뉴 목록 (6종류):
김말이, 김밥, 떡볶이, 라면, 순대, 튀김
```

🔍 해설:
- `[*A, *B, *C]` 전개 연산자 `*`를 써서 여러 리스트를 하나로 합침
- `set(all_orders)` 중복된 메뉴를 제거 (예: 같은 메뉴가 여러 지점에서 주문됨)
- `sorted()` 메뉴명을 가나다순으로 정렬
- `", ".join(...)` 문자열로 이어서 출력 (CSV처럼 보기 좋게)

---
집합 (`set`)
	==중복을 허용하지 않는== 자료 모음입니다.  
	구부렁괄호 `{}`를 사용하지만, 순서가 없습니다.

</> 예시코드:
```python
unique_numbers = {1, "수영", 3, 3, 4, "수영", 5, 5, 5}
print(unique_numbers)
```

🖨️ 출력결과: set은 중복 제거(필터링)은 탁월하지만 순서는 전혀 보장하지 않음
```python
{1, 3, 4, 5, '수영'}
```
---
###### ◽ 리스트 컴프리헨션 (List Comprehension)
	리스트 컴프리헨션은 기존 리스트나 반복 가능한 값들로부터 새로운 
	리스트를 간단한 문법으로 만드는 방법입니다.
	일반적인 for 반복문을 한 줄로 줄여주는 간결하고 직관적인 표현식
	입니다. 람다함수나 삼항 조건 연산자와 같이 for문을 간결하게 표현
	하는 방식입니다.

📖 문법, 구문(syntax): 
```python
[표현식 for 변수 in 반복가능한_값들 if 조건]
```
- `표현식` : 리스트에 담을 값
- `for` : 반복문 (기존 리스트나 range 등에서 하나씩 꺼냄)
- `if 조건` (선택사항) : 조건을 만족하는 값만 포함

</>예시코드:
```python
# 일반적인 for문
numbers = [1, 2, 3, 4, 5]
squares = []  # 결과를 담을 빈 리스트 만들기

for n in numbers:
    squares.append(n * n)

print(squares)

# 리스트 컴프리헨션 버전
numbers = [1, 2, 3, 4, 5]
squares = [n * n for n in numbers]
print(squares)
```

🖨️ 출력:
```python
[1, 4, 9, 16, 25]
```

🔍 해설:
- 기존 리스트 `numbers`에서 각 숫자를 제곱해서 새 리스트에 저장.

</>예시코드:
```python
# 일반적인 for문
numbers = [1, 2, 3, 4, 5]
even = []  # 짝수만 담을 빈 리스트

for n in numbers:
    if n % 2 == 0:        # 짝수 조건
        even.append(n)

print(even)


# 리스트 컴프리헨션 버전
numbers = [1, 2, 3, 4, 5]
even = [n for n in numbers if n % 2 == 0]
print(even)
```

🖨️ 출력:
```python
[2, 4]
```

🔍 해설:
 `even = []`  
    먼저, 짝수만 따로 모아 둘 빈 리스트를 하나 만들어 둡니다.
    
 `for n in numbers`  
    `numbers` 리스트에 있는 숫자들을 하나씩 꺼내서 `n`이라는 이름으로 
    사용합니다.
    
 `if n % 2 == 0`  
	 꺼낸 숫자가 2로 나누어 떨어지는지, 즉 짝수인지 검사합니다.
	 
`even.append(n)`  
    만약 그 숫자가 짝수라면, 결과 리스트(`even`)에 추가합니다.

---
📝 문제3] 여러 개의 중첩된 리스트가 다음과 같이 존재할 때,  
전개 연산자 없이 `flatten`(평탄화)하여 하나의 리스트로 결합해보세요.
```python
data = [[1, 2], [3, 4], [5, 6]]
```

🖨️ 출력 결과:
```python
[1, 2, 3, 4, 5, 6]
```

✅ 정답 코드: 중첩 반복문 사용
```python
data = [[1, 2], [3, 4], [5, 6]]
flattened = []

for group in data:
    for item in group:
        flattened.append(item)

print(flattened)
```

✅ 정답 코드: 리스트 컴프리헨션
```python
data = [[1, 2], [3, 4], [5, 6]]
flattened = [item for group in data for item in group]
print(flattened)
```

🔍 해설:
- 리스트끼리의 `+` 연산도 내부적으로는 전개와 유사한 효과
- 하지만 전개 연산자는 함수 호출이나 가변 인자 처리에도 사용 가능함
---
📝 문제2] 리스트 `[1, 2]`와 `[3, 4]`를 전개 연산자로 합쳐보세요.
```python
a = [1, 2] 
b = [3, 4]
```

🖨️ 출력 결과:
```python
[1, 2, 3, 4]
```

✅ 정답 코드:
```python
a = [1, 2] 
b = [3, 4] 
combined = [*a, *b] 
print(combined)
```

🔍 해설:
- `*a`, `*b`는 각각의 리스트 요소를 하나씩 풀어서 새 리스트에 추가
---
📝 문제1] 리스트 `[10, 20, 30]`을 `print()`로 전개해 출력해보세요.  
(단, 대괄호 없이 숫자만 보이게)
```python
nums = [10, 20, 30]
```

🖨️ 출력 결과:
```python
10 20 30
```

✅ 정답 코드:
```python
nums = [10, 20, 30] 
print(*nums)
```

🔍 해설:
- `*nums`는 `10`, `20`, `30`을 개별 인자로 넘김
- `print()`는 자동으로 공백으로 구분하여 출력
---
###### ◽  리스트(List) – 단일 열(column) 형태의 데이터 저장
	리스트는 같은 종류의 데이터(이름, 상품명, 숫자 등)를 순차적으로 
	저장할 때 사용합니다.

- 사용자 이메일 목록:
    ```python
user_emails = [
    "alice@example.com",
    "bob@example.com",
    "charlie@example.com"
]
```

- API 요청 응답 시간(ms)
    ```python
response_times = [120, 240, 180, 95, 305]  # 밀리초 단위
```

- 재고 알림 상품 ID 리스트
    ```python
low_stock_product_ids = [1023, 2048, 3056, 4981]
```

---
###### ◽  2차원 리스트 (2D List) – 표(table) 형태의 데이터 저장
	행(Row) 과 열(Column) 이 있는 데이터를 표현할 때 사용합니다.  
	리스트 안에 또 다른 리스트를 포함한 구조이며, 엑셀 표 형식의 
	데이터에 적합합니다.
	 표처럼 행과 열로 정리된 데이터를 저장할 때 사용합니다.  
	 즉, 리스트 안에 리스트가 들어 있는 구조예요.

- 직원 근무 시간표 (요일별 근무 시간)
``` python
# 각 행 = 직원 1명 / 각 열 = 월~금 근무시간
work_hours = [
    [8, 8, 8, 8, 6],  # 직원 A
    [9, 9, 9, 9, 0],  # 직원 B
    [7, 7, 7, 7, 7]   # 직원 C
]
```
    
- 매출 데이터 (지점별 월간 매출)
```python
# 각 행 = 지점 / 각 열 = 1월~3월 매출(단위: 백만원)
branch_sales = [
    [120, 135, 150],   # 서울지점
    [90, 100, 110],    # 부산지점
    [70, 85, 95]       # 대구지점
]
```

- 상품 재고 상태
```python
# 상품 이름, 카테고리, 재고 수량
inventory = [
    ["우유", "식품", 20],
    ["마우스", "전자기기", 12],
    ["노트", "문구", 35]
]
```

---
###### ◽ 백엔드 파트에서의 데이터 처리과정
🔄 전체 흐름
1. 데이터 수집 (입력단)
    - 사용자가 **폼**, 앱, 웹사이트, 센서, 외부 API를 통해 데이터를 보냄
    - 입력값 예: 회원가입 정보, 주문내역, 센서 수치, 이미지, CSV 업로드 등

2. 입력 검증 (Validation)
    - 빈 값 체크, 타입 확인, 정규표현식 필터링 등으로 유효성 검증
    - 예: 이메일 형식 확인, 나이 숫자 여부 확인

3. 정제 및 정규화 (Normalization)
    - 대소문자 통일, 날짜 형식 통일, 중복 제거, 공백 제거
    - 예: `2025/5/13` → `2025-05-13`, `" Kim "` → `"kim"`

4. 저장 처리
    - ORM (Django, SQLAlchemy 등) 또는 SQL로 데이터베이스에 저장
    - 테이블 간 ForeignKey 관계 정리 필요 (정규화된 구조)

5. 가공 및 반환
    - 요청에 맞춰 필터링, 정렬, 집계
    - 가공된 데이터를 API 응답으로 제공 (JSON 등)
        
6. 로깅 및 예외 처리
    - 실패 로그 저장 (ex. 로그인 실패)
    - 에러 발생 시 사용자에게 명확한 메시지 전달

---
###### ◽ AI 파트에서의 데이터 처리과정
🔄 전체 흐름
1. 데이터 수집
    - 백엔드(DB)에서 추출하거나, 로그 서버, 센서, 크롤러, 외부 API 활용
    - 일반적으로는 CSV/JSON 또는 SQL 쿼리로 받은 원천 데이터

2. 전처리 (Preprocessing)
    - 결측값 보정 (NaN → 평균/중앙값 등)
    - 이상치 제거 (Z-score, IQR)
    - 범주형 → 수치형 인코딩 (LabelEncoding, OneHotEncoding)
    - 정규화/표준화 (MinMax, Z-score)

3. 특성 엔지니어링 (Feature Engineering)
    - 기존 데이터를 조합하거나 파생변수 생성
    - 예: 로그인 시간 → '야간/주간' 구분, 금액 → 등급화

4. 데이터 분할
    - 학습/검증/테스트 세트로 나눔 (train/test split)
    - 교차검증이 필요한 경우 K-Fold 적용

5. 모델 학습 및 튜닝
    - 알고리즘 적용 (예: XGBoost, YOLO, LSTM 등)
    - 하이퍼파라미터 조정
    - 성능 평가 (정확도, F1-score 등)

6. 추론 및 결과 활용
    - 예측 결과를 다시 DB로 저장하거나 API로 반환
    - 실시간 추천, 이상탐지, 분류 결과 등 서비스에 적용

7. 시각화 및 리포팅
    - Pandas/Matplotlib/Seaborn으로 분석 결과 시각화
    - 경영진 보고용 또는 운영 대시보드로 제공