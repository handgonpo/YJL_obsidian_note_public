# 🔹 리스트 선언하고 요소에 접근하기
	리스트(list)는 여러 개의 값을 하나로 묶어서 저장할 수 있는 
	자료형입니다.  
	쉽게 말하면, 변수를 여러 개 한 번에 저장할 수 있는 상자예요.
	리스트는 [] 스퀘어 브라켓 안에 값들을, 로 구분해서 넣습니다.

📖 문법, 구문(syntax): 
``` python
리스트이름 = [값1, 값2, 값3, ...]
```

</> 예시코드: 리스트 만들기
```python
mixed_list = ["사과", 10, "바나나", 20, "포도", 30]
print(mixed_list)
```

🖨️ 출력 결과:
```python
['사과', 10, '바나나', 20, '포도', 30]
```

◽ 리스트의 요소를 변경하는 기본 문법과 예시

📖 문법, 구문(syntax): 
```python
리스트[인덱스] = 새로운값
```
- 리스트는 mutable(변경 가능) 자료형이기 때문에, 인덱스를 통해 값을 직접 바꿀 수 있습니다.

</> 예시코드: 숫자 리스트의 요소 변경
```python
numbers = [10, 20, 30]
numbers[1] = 99  # 인덱스 1에 해당하는 20을 99로 변경
print(numbers)
```

🖨️ 출력 결과:
```python
[10, 99, 30]
```

</> 예시코드: 문자열 리스트의 요소 변경
```python
fruits = ["apple", "banana", "cherry"]
fruits[0] = "grape"  # 첫 번째 요소 변경
print(fruits)
```

🖨️ 출력 결과:
```python
['grape', 'banana', 'cherry']
```
---
◽ 리스트 안에 튜플이 있는 경우 (튜플 전체 교체)
	튜플(tuple)은 "수정이 불가능한(immutable) 자료형"입니다.

</> 예시코드: 리스트에 튜플이 담긴 구조
```python
data = [("Tom", 25), ("Lucy", 30)]
```
- `data`는 리스트입니다 → 수정 가능 (mutable)
- `("Tom", 25)`는 튜플입니다 → 수정 불가능 (immutable)

❌ 튜플 자체를 수정하려 하면 에러가 납니다
```python
data = [("Tom", 25), ("Lucy", 30)]
data[0][1] = 26
```

⚠️ 오류:
```python
TypeError: 'tuple' object does not support item assignment
```

하지만 리스트의 요소(튜플 전체)를 통째로 바꾸는 건 가능
```python
data = [("Tom", 25), ("Lucy", 30)]

data[0] = ("Tom", 26)  # 첫 번째 튜플 전체를 새 튜플로 교체
print(data)
```

🖨️ 출력 결과:
```python
[('Tom', 26), ('Lucy', 30)]
```
---
</> 예시코드: 리스트에서 요소에 접근하기 (인덱스 사용)
```python
print(fruits[0])  # 첫 번째 요소 
print(fruits[1])  # 두 번째 요소 
print(fruits[2])  # 세 번째 요소
```

🖨️ 출력 결과:
```python
apple banana cherry
```

🔍 해설:
- 리스트는 0부터 번호(index)가 시작돼요!
- `fruits[0]` → 리스트의 첫 번째 요소
- `fruits[2]` → 리스트의 세 번째 요소
- 순서대로 꺼내 쓸 수 있어서 정렬된 데이터 다룰 때 매우 유용
---
#####  ◽ 리스트에서의 IndexError
	IndexError는 리스트에서 없는 위치(index)를 꺼내려고 할 때 발생하는 
	에러(오류)입니다.
	리스트는 0부터 시작하는 순서(index)를 가지고 있고, 존재하지 않는 
	인덱스를 접근하면 오류가 납니다.
	예를 들어, 3개짜리 리스트에서 4번째 요소를 꺼내면 IndexError 발생!

---
</> 예시코드:  IndexError 발생 예
``` python
fruits = ["apple", "banana"]
print(fruits[3])  # ❌ IndexError 발생
```

🖨️ 출력 결과:
```python
IndexError: list index out of range
```

🔍 해설:
- `nums`는 총 3개 요소 → 인덱스는 `0`, `1`, `2`까지만 있어요.
- `nums[3]`은 존재하지 않는 네 번째 요소를 꺼내려고 해서 오류 발생
- 에러 메시지: `"리스트 인덱스가 범위를 벗어났습니다"`
---
# 🔹 튜플
	튜플은 수정이 안 되는(immutable) 자료형이지만, 그래서 오히려 특정 
	상황에서 더 유용하게 쓰입니다. 한 번 생성하면 내부 값을 변경할 수 
	없는(immutable) 구조입니다. 

```python
example = ("apple", 3, True, "한글")
```

◽ 튜플의 특징:
✅ 변경 불가능하여 안전함: 실수로 값을 수정할 위험이 없음
✅ 딕셔너리 키로 사용 가능: 리스트는 안 되지만, 튜플은 가능
```python
# 리스트를 딕셔너리의 키로 사용하면 오류 발생
my_dict = {
    [1, 2, 3]: "리스트를 키로"  # ❌ 오류
}

# 딕셔너리의 키로 사용 가능
my_dict = {
    (1, 2, 3): "튜플을 키로",
    ("Tom", 25): "사용자 정보 키"
}

print(my_dict[(1, 2, 3)])       # 출력: 튜플을 키로
print(my_dict[("Tom", 25)])     # 출력: 사용자 정보 키
```

🖨️ 출력 결과:
```python
튜플을 키로
사용자 정보 키
```

✅ 속도와 메모리 효율성 우수:	리스트보다 처리 속도가 빠르고 가볍다
✅ 데이터 그룹화 용이:	관련 데이터를 묶어서 하나처럼 다룰 수 있음 
    (예: 좌표, 사용자 정보 등)
```python
# 좌표 기반 정보 저장
locations = {
    (37.5665, 126.9780): "서울 시청",
    (35.1796, 129.0756): "부산 시청"
}

print(locations[(37.5665, 126.9780)])  # 출력: 서울 시청
```
---
# 🔹 리스트 연산자: 연결(+), 반복( ), len( )
	리스트는 숫자처럼 연산자(+, * )를 사용할 수 있는 자료형이에요.  
	또한 len() 함수를 사용하면 리스트에 몇 개의 값이 들어있는지도 
	알 수 있어요. 이 세 가지는 리스트를 다룰 때 가장 기본적인 
	도구입니다.

###### ◽ 주요 연산
| 연산      | 의미            | 예시                                 |
| ------- | ------------- | ---------------------------------- |
| `+`     | 리스트 연결        | `[1, 2] + [3, 4]` → `[1, 2, 3, 4]` |
| `*`     | 리스트 반복        | `[0] * 5` → `[0, 0, 0, 0, 0]`      |
| `len()` | 리스트 길이(요소 개수) | `len([10, 20, 30])` → `3`          |

</> 예시코드: 리스트 연결 (+)
``` python
a = [1, 2]
b = [3, 4]
result = a + b
print(result)
```

🖨️ 출력 결과:
```python
[1, 2, 3, 4]
```

🔍 해설:
- 리스트끼리 `+`를 하면 두 리스트가 합쳐짐
- 단, 숫자처럼 덧셈이 아니라 리스트 연결의 의미임

</> 예시코드: 중첩 리스트 연결 + 연산 순서 주의
```python
a = [1, [2, 3]]
b = [[4, 5], 6]

result = a + b
print(result)
```

🖨️ 출력 결과:
```python
[1, [2, 3], [4, 5], 6]
```

🔍 해설:
- 리스트 `a`와 `b`는 둘 다 중첩 리스트(리스트 안에 리스트)를 포함하고 있음
- `+` 연산자는 리스트의 구조 자체는 변형하지 않고 단순히 이어 붙임
- `[2, 3]`과 `[4, 5]`는 각각 하나의 요소(리스트)로 취급됨
- 따라서 중첩된 구조도 그대로 유지됨
---
</> 예시코드: 리스트 반복 ( )
```python
items = ["apple"] * 3 
print(items)
```

🖨️ 출력 결과:
```python
['apple', 'apple', 'apple']
```

🔍 해설:
- `"apple"`이 3번 반복된 리스트가 만들어짐
- `*`는 리스트를 여러 번 복제할 때 사용돼요

예측 
```python
items = [[0]] * 3
[[0],[0],[0]]

items[0][0] = 100
100 0 0

print(items)
```

🔍 해설:
- `[[0]] * 3`은 `[ [0], [0], [0] ]`처럼 보이지만, 같은 리스트 객체를 3번 복사한 것이에요.
- 그래서 `items[0][0] = 100`으로 바꾸면, 모든 하위 리스트가 함께 바뀌어요.   
- 이것을 얕은 복사(shallow copy)라고 합니다.

◽ 내부처리동작
`items = [[0]] * 3` 
- `[[0]]`는 먼저 `[0]`이라는 리스트 하나를 만듭니다.
- `* 3`은 그 하나의 리스트 객체를 3번 복사하는 게 아니라 "3번 참조"하는 것입니다.
- 즉, 구조는 이렇게 됩니다:
```python
items = [same_list, same_list, same_list]
```
- 각각의 `same_list`는 모두 같은 주소를 가진 `[0]`을 가리켜요.
- 그래서 다음 코드:
```python
items[0][0] = 100
```
이렇게 하면 어떤 일이 일어날까요?
- `items[0]`는 `[0]`이고, 그 안의 `[0][0]`은 `0`입니다.
- 여기에 `100`을 할당하면, 그 주소에 있는 값이 100으로 바뀜
- 그런데 `items[1]`, `items[2]`도 같은 리스트를 가리키고 있으므로 → 같이 바뀜!

```python
items = [[0]] * 3

print(id(items[0]))
print(id(items[1]))
print(id(items[2]))
```

🖨️ 출력 결과:
```
140711368540416  
140711368540416  
140711368540416  
```

🧐 처음 보기엔 이렇게 생각할 수 있어요:
```python
items = [[0]] * 3
```
이 코드를 보면:
	“리스트 `[0]`이 세 번 반복되니까 결과가 `[ [0], [0], [0] ]`처럼 서로 다른 리스트3개가 생기겠지?”  라고 생각하기 쉽습니다.

하지만 실제로는 그렇지 않아요!
	이 코드는 리스트 `[0]`을 하나만 만든 다음에,  
	그 하나의 리스트를 3번 복사하는 게 아니라, 3번 가리키는(참조하는) 방식입니다.
즉, 리스트 하나를 만들어 놓고  3번 똑같이 가리키는 리스트가 되는 거예요.

그래서 다음과 같이 코드를 작성하면:
```python
items[0][0] = 100
```
- 첫 번째 리스트의 값을 `100`으로 바꾼 건데,
- 실제로는 나머지 두 리스트도 같은 것을 가리키고 있기 때문에  
    → 전부 `100`으로 바뀌게 됩니다.

즉 위의 코드는 에러는 아니지만 개발자가 의도하지 않은 결과가 나올 수 있어서, '논리적인 오류' 또는 "함정(bug)"이라고 볼 수 있습니다.
```python
[[100], [0], [0]]  ← (기대했던 결과)
```
위와 같이 나오길 기대했을겁니다.

```python
# 의도한 바가 아니라면 이코드를 아래와 같이 수정하세요
items = [[0]] * 3

# 이렇게 수정합니다.
items = [[0], [0], [0]]
```

해결방법:
```python
items = []
items.append([0])
items.append([0])
items.append([0])

items[0][0] = 100
print(items)
```
---
📝 문제 1] 얕은 복사(shallow copy)
리스트 복사 후 수정해보기 다음 코드를 실행하면 어떤 결과가 출력될까요?
```python
a = [1, 2, 3]
b = a
b[0] = 99
print("a:", a)
print("b:", b)
```

🖨️ 출력 결과:
```python
a: [99, 2, 3]  
b: [99, 2, 3]
```

🔍 해설:
- `b = a`는 리스트를 복사한 게 아니라 같은 객체를 참조한 것
- 따라서 `b[0] = 99`로 값을 바꾸면, `a`도 함께 바뀐다
- 이것이 얕은 복사(shallow copy)의 대표적인 예

◽ a 데이터가 안바뀌게 하려면:
```python
a = [1, 2, 3]
b = a        # ❌ 얕은 복사 (같은 객체를 가리킴)
b[0] = 99
print("a:", a)  # ❌ a도 같이 바뀜 → a: [99, 2, 3]
print("b:", b)
```

</> 깊은 복사(deep copy) 슬라이싱 사용 (`[:]`)
```python
a = [1, 2, 3]
b = a[:]       # 새로운 리스트 복사
b[0] = 99
print("a:", a)  # a: [1, 2, 3]
print("b:", b)  # b: [99, 2, 3]
```

</> 깊은 복사(deep copy) list() 함수 사용
```python
a = [1, 2, 3]
b = list(a)     # 새 리스트 생성
b[0] = 99
print("a:", a)  # a: [1, 2, 3]
print("b:", b)  # b: [99, 2, 3]
```
---
📝 문제 2] 다음 코드를 실행했을 때 출력 결과는?
```python
a = [[1, 2], [3, 4]]
b = a * 2
b[0][0] = 100
print(a)
print(b)
```

🌟 힌트: `* 2`는 얕은 복사입니다. 내부 리스트는 그대로 공유됩니다.

✅ 정답 코드:
```python
[[100, 2], [3, 4]]
[[100, 2], [3, 4], [100, 2], [3, 4]]
```

🔍 해설:
- `a * 2`는 `a[0]`, `a[1]`를 복사하는 것이 아니라 그 리스트를 참조하는 새 리스트를 만듭니다.
- 따라서 `b[0][0] = 100`을 하면 `a[0][0]`도 함께 변경됩니다.


```python
a = [[1, 2], [3, 4]]

# 새로 복사된 리스트 b를 직접 만듭니다
b = []

# a의 첫 번째 줄을 복사해서 넣기
b.append([1, 2])

# a의 두 번째 줄을 복사해서 넣기
b.append([3, 4])

# 다시 한 번 같은 걸 복사해서 넣기
b.append([1, 2])
b.append([3, 4])

# b에서 첫 번째 줄의 첫 번째 숫자를 100으로 바꾸기
b[0][0] = 100

print(a)
print(b)
```
---
</> 예시코드:  리스트 길이 구하기 (len)
```python
fruits = ["banana", "mango", "peach"] 
print(len(fruits))
```

🖨️ 출력 결과:
```python
3
```

🔍 해설:
- `len()` 함수는 리스트에 몇 개의 요소가 있는지 알려줌
- 보통 반복문을 돌릴 때, 조건 검사할 때 많이 사용함

</> 예시코드: 중첩 리스트에서 `len()` 함수 사용하기
```python
classroom = [
    ["Alice", "Bob"],
    ["Charlie"],
    ["David", "Eve", "Frank"]
]

print(len(classroom))          # 전체 반의 수
print(len(classroom[2]))       # 세 번째 반의 학생 수
```

🖨️ 출력 결과:
```python
3
3
```

🔍 해설:
- `classroom`은 리스트 안에 리스트가 들어 있는 구조(중첩 리스트)입니다.
- `len(classroom)`은 전체 반(리스트)의 개수 → 3개
- `len(classroom[2])`는 세 번째 반에 있는 학생 이름의 개수 → 3명
---
📝 문제 1] 아래 코드에서 `IndexError`가 발생하지 않도록 수정하고, 마지막 요소를 출력하세요.
```python
fruits = ["apple", "banana", "cherry"]
print(fruits[ len(fruits) ])
```

🖨️ 출력 결과:
```python
cherry
```

✅ 정답 코드:
```python
print(fruits[ len(fruits) - 1 ])  # 마지막 요소 접근
```

🔍 해설:
- `len(fruits)`에서 반환되는 값은 3입니다. 그러나 인덱스 `3`은 존재하지 않음 (`IndexError`)
- 리스트의 인덱스는 `0 ~ len(fruits) - 1` 이므로, `-1`을 빼줘야 마지막 요소에 접근 가능
---
📝 문제 2] 당신은 색깔 목록에서 사용자가 선택한 인덱스 번호에 따라 색상을 보여주는 프로그램을 만들고 있습니다.  
리스트에는 아래와 같은 색상이 저장되어 있습니다.
```python
colors = ["red", "green", "blue", "yellow"]
```
사용자에게 0부터 3 사이의 숫자를 입력받아 해당 색상을 출력하려고 합니다.  
단, 사용자가 0~3 이외의 숫자를 입력하면 `"존재하지 않는 인덱스입니다."` 라고 출력해야 합니다.  
IndexError가 발생하지 않도록 조건문을 사용하여 해결하세요.

🖨️ 출력 예시 1 (예시 입력: `2`):
```python
선택한 색상: blue
```

🖨️ 출력 예시 2 (예시 입력: 5):
```python
존재하지 않는 인덱스입니다.
```

✅ 정답 코드:
```python
colors = ["red", "green", "blue", "yellow"]
i = int(input("색상 번호를 입력하세요 (0~3): "))

if 0 <= i < len(colors):
    print("선택한 색상:", colors[i])
else:
    print("존재하지 않는 인덱스입니다.")
```

🔍 해설:
- `len(colors)`는 4이므로 유효한 인덱스는 `0`, `1`, `2`, `3`
- 조건문 `0 <= i < len(colors)`를 사용하면,  
    존재하지 않는 인덱스를 미리 걸러낼 수 있어 `IndexError`를 방지할 수 있습니다.
---
📝 문제 3] 리스트의 인덱스를 음수를 사용하여 300이 출력되게 프린트 함수를 완성하세요.
```python
nums = [100, 200, 300, 400]
print()
```

✅ 정답 코드:
```python
nums = [100, 200, 300, 400]
print(nums[-2])
```

🔍 해설:
- 파이썬 리스트는 음수 인덱스도 허용함
- `-1`은 마지막 요소, `-2`는 뒤에서 두 번째 요소  
    → `nums[-2]`는 `300`
---
📝 문제 4] 리스트 내부에 있는 문자열 각각의 인덱스를 이용해, 모든 단어의 첫 글자만 출력하세요.
```python
words = ["python", "list", "index", "error"]
```

🖨️ 출력 결과:
```python
p
l
i
e
```

```python
words = ["python", "list", "index", "error"]

if len(words) > 0:
	print(words[0][0]) # p

if len(words) > 1:
	print(words[1][0]) # l

if len(words) > 2:
	print(words[2][0]) # i

if len(words) > 3:
	print(words[3][0]) # e			
```
---
# 🔹 리스트 요소 추가: append( ), insert( )
	리스트 요소 추가는 리스트에 새로운 값을 넣는 방법입니다.  
	대표적으로 append()와 insert() 메서드를 사용합니다.

| 메서드            | 기능 설명                  |
| -------------- | ---------------------- |
| `append(x)`    | 리스트 맨 뒤에 x 추가          |
| `insert(i, x)` | i번째 위치에 x 삽입 (기존 값 밀림) |

◽ append( ) 함수
	`append()`는 리스트의 마지막에 새로운 요소를 추가할때 사용합니다. 
	형식: `리스트.append(요소)`

</> 예시코드: `append()`로 맨 끝에 요소 추가하기
``` python
numbers = [1, 2, 3]
numbers.append(4)
print(numbers)
```

🖨️ 출력 결과:
```python
[1, 2, 3, 4]
```

🔍 해설:
- 여러 개를 한 번에 추가하려면 `append([4, 5])`가 아닌 `extend()`나 `+` 연산이 필요하지만,  여기서는 하나씩 추가하는 방식을 배웁니다.

---
◽ insert( ) 함수
	리스트의 특정 위치(인덱스)에 새로운 요소를 삽입할 때 사용합니다.
	형식: `리스트.insert(인덱스, 요소)`

</> 예시코드: `insert()`로 원하는 위치에 삽입하기
```python
fruits = ["apple", "banana", "grape"] 
fruits.insert(1, "orange") 
print(fruits)
```

🖨️ 출력 결과:
```python
['apple', 'orange', 'banana', 'grape']
```

🔍 해설:
- `insert(1, "orange")`는 `"orange"`를 index 1 위치에 삽입
- 기존의 `"banana"`는 뒤로 밀려나서 `2번째` 위치가 됨

---
##### ◽ 리스트 연결 연산자와 요소 추가의 차이
	리스트에 새로운 값을 넣는 방법은 여러 가지가 있습니다. 
	그중 자주 혼동되는 것이 바로
	- append() 메서드
	- 리스트 연결 연산자 +
	두 방법 모두 리스트에 값을 추가할 수 있지만, 동작 방식은 매우 
	다릅니다.

</> 예시코드: `append()`는 리스트 안에 리스트를 통째로 넣음
```python
a = [1, 2] 
a.append([3, 4]) 
print(a)
```

🖨️ 출력 결과:
```python
[1, 2, [3, 4]]
```

🔍 해설:
- `append()`는 전체를 하나의 요소로 추가
- 즉, `[3, 4]`라는 리스트 그 자체가 한 칸으로 들어감
- 결과적으로 리스트 안에 리스트(중첩 리스트)가 생김

---
</> 예시코드: `+` 연산자는 두 리스트를 연결해서 새 리스트로 만듦
```python
b = [1, 2] 
b = b + [3, 4] 
print(b)
```

🖨️ 출력 결과:
```python
[1, 2, 3, 4]
```

🔍 해설:
- `+` 연산은 두 리스트를 이어 붙이는 것
- 결과는 새로운 리스트 → 원래 있던 리스트는 변하지 않고 새로운 리스트로 대체
- `[3, 4]`가 하나의 요소가 아니라, 개별 요소로 들어감
---
📝 문제1] 당신은 할 일 목록을 리스트로 만들고 있습니다.  
먼저 `["공부하기", "청소하기"]`라는 리스트가 있고,  여기에 `"운동하기"`라는 항목을 리스트의 마지막에 추가하려고 합니다.  어떤 함수를 사용해야 할까요? 
해당 코드를 작성하고 결과를 출력하세요.
```python
todo = ["공부하기", "청소하기"]
```

🖨️ 출력 결과:
```python
['공부하기', '청소하기', '운동하기']
```

✅ 정답:
```python
todo = ["공부하기", "청소하기"]
todo.append("운동하기")
print(todo)
```

🔍 해설:
-  `append()`는 리스트 끝에 요소 하나를 추가할 때 사용
- 기존 요소들은 그대로 있고, `"운동하기"`가 마지막에 붙음
---
📝 문제2] 도서 목록 `["책A", "책B", "책C"]`가 있을 때,  가장 앞에 `"신간도서"`를 삽입해서 우선순위를 높이려고 합니다.  어떻게 해야 `"신간도서"`가 가장 앞에 오게 될까요?
```python
books = ["책A", "책B", "책C"]
```

🖨️ 출력 결과:
```python
['신간도서', '책A', '책B', '책C']
```

✅ 정답 코드:
```python
books = ["책A", "책B", "책C"]
books.insert(0, "신간도서")
print(books)
```

🔍 해설:
- `insert(0, ...)`은 리스트의 0번째 자리에 삽입한다는 의미
- 나머지 요소들은 자동으로 한 칸씩 뒤로 밀림
---
📝 문제3] 다음 코드에서 `append()`와 `+` 연산자를 사용한 결과는 어떻게 다를까요?  코드를 실행한 후 `nums1`과 `nums2`의 결과를 비교해보세요.
```python
nums1 = [1, 2]
nums1.append([3, 4])

nums2 = [1, 2]
nums2 = nums2 + [3, 4]
```

🖨️ 출력 결과:
```python
append 결과: [1, 2, [3, 4]]
연결 연산자 결과: [1, 2, 3, 4]
```

🔍 해설:
- `append([3, 4])`는 리스트 자체를 한 덩어리로 추가
- `+ [3, 4]`는 리스트를 풀어서 이어붙임
- 따라서 `append` 결과는 중첩 리스트가 되고, `+`는 낱개 요소가 추가됨
---
📝 문제4] 사용자에게 3개의 영화 제목을 입력받아, 입력한 순서대로 리스트에 `insert()`를 사용해 항상 맨 앞에 추가하려고 합니다.  
출력결과와 사용자 입력예시를 참고하여 코드를 작성하세요.

🖨️ 출력 결과:
```python
저장된 영화 목록: ['Terminator', 'Avatar', 'Titanic']
```

🖨️ 사용자 입력 예시:
```python
첫 번째 영화: Titanic  
두 번째 영화: Avatar  
세 번째 영화: Terminator
```

✅ 정답 코드:
```python
movies = []

movie1 = input("첫 번째 영화: ")
movies.insert(0, movie1) # 첫 번째 영화: Terminator

movie2 = input("두 번째 영화: ")
movies.insert(0, movie2) # 두 번째 영화: Avatar

movie3 = input("세 번째 영화: ")
movies.insert(0, movie3) # 세 번째 영화: Titanic

print("저장된 영화 목록:", movies)
```

🔍 해설:
- `insert(0, ...)`를 반복하면 새로운 입력이 항상 맨 앞에 쌓임
- 따라서 가장 마지막에 입력한 항목이 리스트의 맨 앞에 위치하게 됨

---
# 🔹 리스트 요소 제거하기
	리스트는 값을 추가하는 것뿐만 아니라, 필요 없는 값을 제거할 수도 
	있습니다.  
	예를 들어, 잘못 들어간 데이터를 빼거나, 사용한 값을 삭제하는 등  
	데이터를 유지보수하거나 정리할 때 꼭 필요한 기능이에요.

리스트에서 요소를 제거하는 방법은 여러 가지가 있는데,  
이번에는 인덱스를 기준으로 요소를 제거하는 방법을 알아보겠습니다.

##### ◽  `del` 키워드란?
	del은 파이썬의 삭제 전용 키워드로, 리스트에서 특정 위치(index)의 
	값을 제거할 때 사용합니다.

</> 예시코드:  del로 리스트 요소 삭제
```python
nums = [10, 20, 30, 40] 

del nums[1] 
print(nums)
```

🖨️ 출력 결과:
```python
[10, 30, 40]
```

🔍 해설:
- `nums[1]` 위치의 값인 `20`이 삭제됨 
- 삭제된 자리는 사라지고, 나머지 값들이 앞으로 당겨짐
- 리스트 자체가 바로 바뀜 (in-place)
---
##### ◽ `pop()` 메서드란?
	pop()은 리스트에서 특정 위치의 값을 꺼내서 삭제합니다.  
	삭제와 동시에 그 값을 반환(돌려줌)하는 기능이 있어요.
	
- 아무 것도 쓰지 않으면 마지막 요소를 제거
- `pop(index)`처럼 쓰면 해당 인덱스의 요소를 제거

</> 예시코드:  pop( )으로 마지막 요소 제거
```python
letters = ['a', 'b', 'c'] 
removed = letters.pop() 

print("삭제된 값:", removed) 
print("남은 리스트:", letters)
```

🖨️ 출력 결과:
```python
삭제된 값: c   
남은 리스트: ['a', 'b']
```

</> 예시코드:  pop(index)로 중간 요소 제거
```python
letters = ['a', 'b', 'c'] 
letters.pop(0) 
print(letters)
```

🖨️ 출력 결과:
```python
['b', 'c']
```

🔍 해설:
- `pop(0)` → 0번 인덱스의 `'a'`를 제거함
- `pop()`은 삭제한 값을 되돌려받을 수 있다는 점이 `del`과 차이점

---
##### ◽값으로 제거하기 : remove( )
	리스트에서 특정값 하나를 제거합니다. 가장먼저 나오는 값 하나만 제거됨

</> 예시코드:
```python
fruits = ["apple", "banana", "apple", "cherry"]
fruits.remove("apple")
print(fruits)
```

🖨️ 출력 결과:
```python
['banana', 'apple', 'cherry']
```

🔍 해설:
- `remove("apple")`은 리스트에서 첫 번째로 나오는 'apple'만 제거합니다.
- 나머지 `'apple'`은 그대로 유지됨.
- 만약 제거하려는 값이 리스트에 없으면 에러가 발생합니다.

---
##### ◽모두 제거하기: clear( )
	리스트 안의 모든 요소를 한 번에 제거합니다.  
	(리스트는 남고, 내용만 비워짐)

</> 예시코드:
```python
numbers = [1, 2, 3, 4]
numbers.clear()
print(numbers)
```

🖨️ 출력 결과:
```python
[]
```

🔍 해설:
- `clear()`는 리스트를 비우는 함수입니다.
- 리스트 객체는 그대로 있지만, 요소가 모두 삭제되어 빈 리스트가 됩니다.
- 나중에 다시 `append()`로 요소를 추가할 수 있습니다.

---
##### ◽ 리스트 간 빼기는 안 됨 ❌
```python
a = [1, 2, 3]
b = [2, 3]
print(a - b)
```

🛑 🖨️ 출력 결과:
```python
TypeError: unsupported operand type(s) for -: 'list' and 'list'
```

🔍 해설:
- 리스트끼리 `-` 연산은 안 됩니다
- 파이썬은 리스트 간 빼기를 직접 지원하지 않음

---
##### ◽ 리스트에서 값을 뺀 결과를 새로 만들기 (값 변경)
```python
a = [10, 20, 30]
b = [a[0] - 5, a[1] - 5, a[2] - 5]
print(b)
```

🖨️ 출력 결과:
```python
[5, 15, 25]
```

🔍 해설:
- 리스트 `a`의 각 요소에서 5씩 빼서 새로운 리스트 `b`를 만든 것
---
📝 문제1] 당신은 숫자 리스트 `[10, 20, 30, 40, 50]`에서  세 번째 값(`30`)을 인덱스를 이용해 삭제하려고 합니다.  
`del` 키워드를 사용해 코드를 작성하고, 최종 리스트를 출력해보세요.
```python
nums = [10, 20, 30, 40, 50]
```

🖨️ 출력 결과:
```python
[10, 20, 40, 50]
```

✅ 정답:
```python
nums = [10, 20, 30, 40, 50]
del nums[2]
print(nums)
```

🔍 해설:
- `del`은 인덱스로 삭제할 때 사용
- `nums[2]`는 `30`이므로 삭제되고, 나머지 값들이 앞으로 당겨짐

---
📝 문제2] 과일 리스트 `["apple", "banana", "cherry", "banana"]`에서  
처음 나오는 `"banana"` 하나만 삭제하려고 합니다.  값으로 삭제하는 방법을 사용하세요.

🖨️ 출력 결과:
```python
['apple', 'cherry', 'banana']
```

✅ 정답:
```python
fruits = ["apple", "banana", "cherry", "banana"]
fruits.remove("banana")
print(fruits)
```

🔍 해설:
-  `remove("banana")`는 처음 나타나는 `"banana"`만 삭제
- 나중에 나오는 `"banana"`는 그대로 남아 있음

---
📝 문제3] 다음 코드는 `pop()`을 사용하여 마지막 값을 꺼내고,  그 값을 따로 저장한 후 출력한 후  리스트도 출력해보세요.
리스트: `[100, 200, 300]`  
마지막 값을 꺼내고, 꺼낸 값과 리스트의 상태를 출력해보세요.
```python
scores = [100, 200, 300]
```

🖨️ 출력 결과:
```python
꺼낸 점수: 300
남은 점수: [100, 200]
```

✅ 정답:
```python
scores = [100, 200, 300]
last_score = scores.pop()
print("꺼낸 점수:", last_score)
print("남은 점수:", scores)
```

🔍 해설:
-  `pop()`은 삭제 + 반환
- 꺼낸 값을 따로 저장할 수 있어 이후에도 사용할 수 있음

---
📝 문제 4] 리스트에 여러 개의 데이터를 저장한 후,  모든 요소를 한꺼번에 비우고 싶습니다. `clear()` 함수를 사용해 리스트를 완전히 초기화하세요.
```python
data = ["python", "java", "c++"]
```

🖨️ 출력 결과:
```python
초기화된 리스트: []
```

✅ 정답:
```python
data = ["python", "java", "c++"]
data.clear()
print("초기화된 리스트:", data)
```

🔍 해설:
- `clear()`는 리스트를 완전히 비움
- 리스트 객체는 그대로 있고, 요소만 없어져 빈 리스트가 됨
---
# 🔹 리스트 정렬하기: sort( )
	리스트에 들어 있는 숫자나 글자들을 순서대로 정렬하고 싶을 때  
	파이썬에서는 sort() 메서드를 사용합니다.
	sort()는 리스트를 오름차순(작은 값 → 큰 값)으로 정렬하며,  
	원한다면 내림차순(큰 값 → 작은 값)으로도 바꿀 수 있어요.
	sort()는 리스트 안에 있는 값들의 순서를 정리해주는 도구입니다.

📖 문법, 구문(syntax)
```python
리스트.sort()  # 오름차순 정렬
리스트.sort(reverse=True) # 내림차순 정렬
```

###### ◽ 정렬 순서 
| 종류  | 예시 문자       | 유니코드 순서     | 정렬 위치 |
| --- | ----------- | ----------- | ----- |
| 숫자  | `'0'`~`'9'` | U+0030~0039 | 가장 앞  |
| 대문자 | `'A'`~`'Z'` | U+0041~005A | 그 다음  |
| 소문자 | `'a'`~`'z'` | U+0061~007A | 그 다음  |
| 한글  | `'가'`~      | U+AC00~     | 가장 뒤  |

```python
mixed = ["apple", "Apple", "가나다", "Banana", "banana", "123", "Zebra", "zoo", "가방", "100", "10"]

mixed.sort()
print(mixed)
```

🖨️ 출력 결과:
```python
['10', '100', '123', 'Apple', 'Banana', 'Zebra', 'apple', 'banana', 'zoo', '가나다', '가방']
```

🔍 해설:
- 숫자 문자열 `'10'`, `'100'`, `'123'` 가장 먼저 정렬됨 
- 대문자 문자열 `'Apple'`, `'Banana'`, `'Zebra'`
- 소문자 문자열 `'apple'`, `'banana'`, `'zoo'`
- 한글 문자열 `'가나다'`, `'가방'`
    가장 마지막에 정렬됨 (한글의 유니코드가 가장 크기 때문)

</> 예시코드: 내림차순 정렬
```python
mixed = ["apple", "Apple", "가나다", "Banana", "banana", "123", "Zebra", "zoo", "가방", "100", "10"]
mixed.sort(reverse = True)
print(mixed)
```

🖨️ 출력 결과:
```python
['가방', '가나다', 'zoo', 'banana', 'apple', 'Zebra', 'Banana', 'Apple', '123', '100', '10']
```

🔍 해설:
- `reverse=True`를 주면 유니코드 순서의 역방향으로 정렬됩니다.
- 즉, 유니코드 값이 큰 것부터 작은 것 순서로 나열됩니다.

정렬 순서 (내림차순일 때):
1. 한글 → 유니코드 값이 가장 큼 → 제일 앞에 정렬
2. 소문자 (`zoo`, `banana`, `apple`)
3. 대문자 (`Zebra`, `Banana`, `Apple`)
4. 숫자 문자열 (`123`, `100`, `10`) → 유니코드상 가장 작으므로 마지막
---
###### ◽  `sort()` vs `sorted()`
| 함수 이름      | 원본 리스트 <br>변경 여부 | 반환값                | 사용 목적                          |
| ---------- | ---------------- | ------------------ | ------------------------------ |
| `sort()`   | 원본을 직접 변경        | None 변수에 <br>저장 불가 | 리스트 자체를 정렬하고 싶을 때              |
| `sorted()` | 원본은 그대로 유지       | 새로운 리스트 반환         | 원본은 그대로 두고 정렬 결과만 따로 저장하고 싶을 때 |
</> 차이를 보여주는 예시코드:
```python
original = ["banana", "Apple", "가나다", "123", "apple", "Zebra", "가방", "10"]
new_sorted = sorted(original)

print("원본 리스트:", original)
print("정렬된 새 리스트:", new_sorted)
```

🖨️ 출력 결과:
```python
원본 리스트: ['banana', 'Apple', '가나다', '123', 'apple', 'Zebra', '가방', '10']
정렬된 새 리스트: ['10', '123', 'Apple', 'Zebra', 'apple', 'banana', '가나다', '가방']
```

🔍 해설:
- `sorted(original)`은 원본을 변경하지 않음
    - `original`은 그대로 유지
- 정렬 기준은 유니코드 순서
    - `숫자 문자열` → `'10'`, `'123'`이 가장 앞
    - `대문자` → `'Apple'`, `'Zebra'`
    - `소문자` → `'apple'`, `'banana'`
    - `한글` → `'가나다'`, `'가방'`이 가장 뒤
- 새로 만들어진 리스트 `new_sorted`는 정렬된 결과를 담고 있음
---
###### ◽ `sorted( )`함수

📖 문법, 구문(syntax): 
```python
sorted(리스트, key=정렬기준함수)
```

###### ◽ `key` 매개변수란?
	정렬 함수(`sorted()`, `sort()`)에서 정렬 기준을 내 마음대로 설정
	할 수 있게 해주는 옵션입니다.

###### ◽ 자주 쓰는 `key` 함수 예시
| `key` 값              | 설명                          | 예시 결과                        |
| -------------------- | --------------------------- | ---------------------------- |
| `key=str.lower`      | 모두 소문자로 변환해 비교 (대소문자 무시 정렬) | "apple", "Apple" 순서 통일       |
| `key=str.upper`      | 모두 대문자로 변환해 비교              | 대소문자 구분 없이 정렬                |
| `key=len`            | 요소의 길이를 기준으로 정렬             | 문자열 길이 순 정렬                  |
| `key=int`            | 숫자형 문자열을 숫자로 변환해 정렬         | `"10"`과 `"2"` 비교 시 `"2"`가 먼저 |
| `key=lambda x: x[1]` | 튜플의 두 번째 요소 기준으로 정렬         | `(a, 2)`의 `2` 기준 정렬          |

---
</> 예시코드: `key=str.lower` – 대소문자 구분 없이 정렬
```python
names = ["banana", "Apple", "cherry", "apple"]
names.sort(key=str.lower)
print(names)
```

🖨️ 출력 결과:
```python
['Apple', 'apple', 'banana', 'cherry']
```

🔍 해설:
- `str.lower`는 모든 값을 소문자로 변환해서 비교
- 하지만 출력 결과는 원래 대소문자 그대로 유지
- `'Apple'`과 `'apple'`은 비교 기준으로 같지만, 원래 순서대로 정렬됨
---
</> 예시코드: `key=len` – 길이 기준 정렬
```python
words = ["dog", "elephant", "cat", "tiger"]
words.sort(key=len)
print(words)
```

🖨️ 출력 결과:
```python
['dog', 'cat', 'tiger', 'elephant']
```

🔍 해설:
- 각 단어의 길이(`len`)를 기준으로 정렬
- 길이가 짧은 단어부터 긴 단어 순으로 나열됨
---
</> 예시코드:  `key=int` – 숫자 문자열을 실제 숫자처럼 정렬
```python
nums = ["10", "2", "30", "1"]
nums.sort(key=int)
print(nums)
```

🖨️ 출력 결과:
```python
['1', '2', '10', '30']
```

🔍 해설:
- 문자열이지만 `int`로 변환해서 숫자처럼 정렬
- 일반 문자열 정렬이면 `"10"`이 `"2"`보다 앞에 와야 하지만,  
    `int`를 쓰면 실제 숫자값 10과 2를 비교함
---
</> 예시코드: `key=lambda x: x[1]` – 튜플의 두 번째 값 기준 정렬
```python
students = [("민수", 85), ("영희", 95), ("철수", 90)]
students.sort(key=lambda x: x[1])
print(students)
```

🖨️ 출력 결과:
```python
[('민수', 85), ('철수', 90), ('영희', 95)]
```

🔍 해설:
- 각 튜플의 두 번째 값(점수)을 기준으로 오름차순 정렬
- `lambda x: x[1]`는 `요소x = ("민수", 85)`  `x[1] 값 = 85` 이 뜻으로 점수기준으로 정렬하겠다는 뜻입니다.
---
</> 예시코드: `ey=lambda x: x[::-1]` – 문자열을 뒤집은 값 기준 정렬
```python
words = ["abc", "xyz", "bca", "cab"]
words.sort(key=lambda x: x[::-1])
print(words)
```

🖨️ 출력 결과:
```python
['bca', 'cab', 'abc', 'xyz']
```

◽ 순차적으로 단계처리과정
✅ 1단계: 각 요소를 거꾸로 만들기
```python
words = ["abc", "xyz", "bca", "cab"]

"abc" -> "cba"
"xyz" -> "zyx"
"bca" -> "acb"
"cab" -> "bac"
```

✅ 2단계:  뒤집은 값을 기준으로 알파벳 오름차순 정렬
```python
"abc" -> "bca"
"bca" -> "cab"
"cab" -> "abc"
"xyz" -> "xyz"

# 정렬기준 
"acb" < "bac" < "cba" < "zyx"
```

✅ 3단계: 최종결과
```python
["bca", "cab", "abc", "xyz"]
```

🔍 해설:
- 리스트 words를 정렬하되 각 단어를 거꾸로 뒤집은 값을 기준으로 정렬됩니다.
- 1차 원래단어를 뒤집고
- 2차 뒤집힌 값들을 알파벳 순으로 정렬합니다.
- `lambda x: x[::-1]`는 단어를 거꾸로 만드는 함수로 단어를 뒤집은 결과 기준으로 정렬됩니다.
- 그래서 단순히 `["abc", "bca", "cab", "xyz"]` 이렇게 정렬되지 않고 거꾸로 봤을때 순서대로 정렬됩니다.
---
# 🔹 in / not in 연산자
	리스트 안에 특정 값이 들어있는지 확인하고 싶을 때, 파이썬에서는 
	in 연산자 또는 not in 연산자를 사용합니다.
	"값 in 리스트" → 값이 리스트 안에 있으면 True, 없으면 False  
	"값 not in 리스트" → 값이 리스트 안에 없으면 True

📖 문법, 구문(syntax): 
```python
값 in 리스트       # 값이 들어 있으면 True 
값 not in 리스트   # 값이 없으면 True
```

</> 예시코드: 값이 리스트에 있는 경우
```python
fruits = ["apple", "banana", "cherry"] 
print("banana" in fruits)
```

🖨️ 출력 결과:
```python
True
```

</> 예시코드:  값이 리스트에 없는 경우
```python
numbers = [1, 2, 3] 

print(5 in numbers) 
print(5 not in numbers)
```

🖨️ 출력 결과:
```python
False 
True
```

🔍 해설:
- `5`는 리스트 안에 없으므로 `in`은 `False`, `not in`은 `True`
---
</> 예시코드:  조건문과 함께 사용
```python
colors = ["red", "blue", "green"] 

if "green" in colors:     
	print("green이 포함되어 있어요!")
```

🖨️ 출력 결과:
```python
green이 포함되어 있어요!
```

🔍 해설:
- `"green"`이 리스트에 있는지 확인한 후 메시지 출력
- 이런 방식은 검색 기능, 필터링, 중복 확인 등에 활용 가능
---
📝 문제1] 사용자에게 동물 이름을 입력받아, 리스트에 있는지 검사한 후 결과를 출력하세요.

단, 입력값의 대소문자는 구분하지 않고 비교하세요.
```python
animals = ["cat", "dog", "bird", "rabbit"] 
```

🖨️ 출력 결과:
```python
리스트에 있습니다!
```

✅ 정답 코드:
```python
animals = ["cat", "dog", "bird", "rabbit"]
word = input("동물 이름을 입력하세요: ")

if word.lower() in animals:
    print("리스트에 있습니다!")
else:
    print("리스트에 없습니다.")
```

🔍 해설:
	사용자의 입력값이 `"Dog"`처럼 대문자를 포함하더라도, `lower()`로 소문자로 바꿔 비교하면 리스트 안의 `"dog"`과 일치 가능

---
📝 문제2] 리스트 `["red", "blue"]`에 `"green"`이 없을 때만 `"green 없음"`을 출력해보세요.

🖨️ 출력 결과:
```python
green 없음
```

✅ 정답 코드:
```python
colors = ["red", "blue"]  

if "green" not in colors:     
	print("green 없음")
```

🔍 해설:
- `"green"`은 리스트에 없기 때문에 `not in` 조건이 `True`가 되어 출력됨
---
📝 문제3] 다음은 금지어가 있는 단어 리스트입니다.
사용자가 입력한 단어가 금지어 리스트에 없을 경우에만 `"사용 가능"`을 출력하세요.
```python
banned_words = ["badword", "uglyword", "hate"]
```

🖨️ 출력 결과(입력: hello):
```python
사용 가능
```

✅ 정답 코드:
```python
banned_words = ["badword", "uglyword", "hate"]
word = input("사용할 단어를 입력하세요: ")

if word not in banned_words:
    print("사용 가능")
else:
    print("금지된 단어입니다.")
```

---
# 🔹 for 반복문
	for 반복문은 리스트처럼 여러 개의 값이 들어 있는 자료형을 하나씩 
	꺼내서 사용할 때 사용하는 문법이에요.  
	반복문을 사용하면 코드를 반복해서 실행할 수 있어 아주 편리하고 
	강력합니다.
	
"리스트에 들어 있는 값들을 하나씩 꺼내서 반복 실행하는 구조"입니다.

📖 문법, 구문(syntax): 
```python
for 변수 in 리스트:     
	실행할 코드
```

- 리스트 안에 있는 값이 하나씩 `변수`에 들어가며 `코드 블록`이 실행됨
- 리스트에 값이 5개면 코드가 5번 실행됨
---
</> 예시코드: 대소문자 섞인 리스트에서 모두 소문자로 바꿔 출력하기
```python
colors = ["Red", "GREEN", "bLue", "YELLOW"]

for color in colors:
    print(color.lower())
```

🖨️ 출력 결과:
```python
red  
green  
blue  
yellow
```

🔍 해설:
- `str.lower()`를 사용하여 대소문자 섞인 값을 모두 소문자로 통일해 출력
- 문자열 전처리 시 자주 쓰이는 방식
---
</> 예시코드: 숫자 리스트 중 짝수만 2배로 출력, 나머지는 무시
```python
nums = [4, 7, 10, 3, 8]

for n in nums:
    if n % 2 == 0:
        print(n * 2)
```

🖨️ 출력 결과:
```python
8  
20  
16
```

🔍 해설:
-  짝수만 필터링 (`n % 2 == 0`)
- 짝수일 경우에만 2배로 곱해서 출력
- 실무에서도 데이터 필터링 시 자주 사용
---
</> 예시코드: 음식 리스트에서 'bread'가 포함된 항목만 영어 문장으로 출력
```python
foods = ["banana bread", "rice", "bread", "noodles", "garlic bread"]

for food in foods:
    if "bread" in food:
        print(f"{food} contains bread!")
```

🖨️ 출력 결과:
```python
banana bread contains bread!  
bread contains bread!  
garlic bread contains bread!
```

🔍 해설:
- 리스트에서 꺼낸 문자열 `food`를 활용해 문장을 만들어 출력
---
</> 예시코드: 문자열 리스트의 첫 글자만 모아서 새 리스트로 만들기
```python
names = ["Alice", "Bob", "Michael", "Diana"]
first_letters = []

for name in names:
    first_letters.append(name[0])

print(first_letters)
```

🖨️ 출력 결과:
```python
['A', 'B', 'M', 'D']
```

🔍 해설:
- 문자열 인덱싱으로 첫 글자 추출
- 추출된 값을 다른 리스트에 저장
- 리스트 변환과 축약에 유용한 방식

---
📝 문제1] 숫자 리스트에서 3의 배수만 출력하세요.
```python
nums = [4, 6, 7, 9, 12, 15, 18]
```

✅ 정답 코드:
```python
nums = [4, 6, 7, 9, 12, 15, 18]

for n in nums:
    if n % 3 == 0:
        print(n)
```

🔍 해설:
- `n % 3 == 0` 조건으로 3의 배수만 필터링하여 출력
---
📝 문제2] 동물 리스트에 대해 `"I like ___"` 형식으로 출력하되,
"cat"일 때만 "I love cat" 이라고 출력하세요.
```python
animals = ["dog", "cat", "fox"]
```

🖨️ 출력 결과:
```python
I like dog  
I love cat  
I like fox
```

✅ 정답 코드:
```python
animals = ["dog", "cat", "fox"]

for animal in animals:
    if animal == "cat":
        print("I love cat")
    else:
        print("I like " + animal)
```

🔍 해설:
- 특정 값("cat")일 때만 예외 처리
- `if-else` 조건문을 반복문 안에 사용
----

